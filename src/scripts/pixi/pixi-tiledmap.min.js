!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports["pixi-tiledmap"] = e() : t["pixi-tiledmap"] = e() }(window, function () {
  return function (x) { var n = window.webpackHotUpdatepixi_tiledmap; window.webpackHotUpdatepixi_tiledmap = function (t, e) { !function (t, e) { if (!M[t] || !h[t]) return; for (var n in h[t] = !1, e) Object.prototype.hasOwnProperty.call(e, n) && (C[n] = e[n]); 0 == --l && 0 === c && g() }(t, e), n && n(t, e) }; var a, r = !0, R = "fdfee4e533f18247d128", e = 1e4, N = {}, L = [], i = []; function o(e) { var n = U[e]; if (!n) return j; function r(t) { return n.hot.active ? (U[t] ? -1 === U[t].parents.indexOf(e) && U[t].parents.push(e) : (L = [e], a = t), -1 === n.children.indexOf(t) && n.children.push(t)) : (console.warn("[HMR] unexpected require(" + t + ") from disposed module " + e), L = []), j(t) } function t(e) { return { configurable: !0, enumerable: !0, get: function () { return j[e] }, set: function (t) { j[e] = t } } } for (var i in j) Object.prototype.hasOwnProperty.call(j, i) && "e" !== i && "t" !== i && Object.defineProperty(r, i, t(i)); return r.e = function (t) { return "ready" === D && P("prepare"), c++ , j.e(t).then(e, function (t) { throw e(), t }); function e() { c-- , "prepare" === D && (f[t] || p(t), 0 === c && 0 === l && g()) } }, r.t = function (t, e) { return 1 & e && (t = r(t)), j.t(t, -2 & e) }, r } var s = [], D = "idle"; function P(t) { D = t; for (var e = 0; e < s.length; e++)s[e].call(null, t) } var u, C, F, l = 0, c = 0, f = {}, h = {}, M = {}; function B(t) { return +t + "" === t ? +t : t } function d(t) { if ("idle" !== D) throw new Error("check() is only allowed in idle status"); return r = t, P("check"), function (t) { return t = t || 1e4, new Promise(function (e, n) { if ("undefined" == typeof XMLHttpRequest) return n(new Error("No browser support")); try { var r = new XMLHttpRequest, i = j.p + "" + R + ".hot-update.json"; r.open("GET", i, !0), r.timeout = t, r.send(null) } catch (t) { return n(t) } r.onreadystatechange = function () { if (4 === r.readyState) if (0 === r.status) n(new Error("Manifest request to " + i + " timed out.")); else if (404 === r.status) e(); else if (200 !== r.status && 304 !== r.status) n(new Error("Manifest request to " + i + " failed.")); else { try { var t = JSON.parse(r.responseText) } catch (t) { return void n(t) } e(t) } } }) }(e).then(function (t) { if (!t) return P("idle"), null; h = {}, f = {}, M = t.c, F = t.h, P("prepare"); var e = new Promise(function (t, e) { u = { resolve: t, reject: e } }); C = {}; return p(1), "prepare" === D && 0 === c && 0 === l && g(), e }) } function p(t) { M[t] ? (h[t] = !0, l++ , function (t) { var e = document.createElement("script"); e.charset = "utf-8", e.src = j.p + "" + t + "." + R + ".hot-update.js", document.head.appendChild(e) }(t)) : f[t] = !0 } function g() { P("ready"); var e = u; if (u = null, e) if (r) Promise.resolve().then(function () { return _(r) }).then(function (t) { e.resolve(t) }, function (t) { e.reject(t) }); else { var t = []; for (var n in C) Object.prototype.hasOwnProperty.call(C, n) && t.push(B(n)); e.resolve(t) } } function _(n) { if ("ready" !== D) throw new Error("apply() is only allowed in ready status"); var t, e, r, c, i; function a(t) { for (var e = [t], n = {}, r = e.slice().map(function (t) { return { chain: [t], id: t } }); 0 < r.length;) { var i = r.pop(), a = i.id, o = i.chain; if ((c = U[a]) && !c.hot._selfAccepted) { if (c.hot._selfDeclined) return { type: "self-declined", chain: o, moduleId: a }; if (c.hot._main) return { type: "unaccepted", chain: o, moduleId: a }; for (var s = 0; s < c.parents.length; s++) { var u = c.parents[s], l = U[u]; if (l) { if (l.hot._declinedDependencies[a]) return { type: "declined", chain: o.concat([u]), moduleId: a, parentId: u }; -1 === e.indexOf(u) && (l.hot._acceptedDependencies[a] ? (n[u] || (n[u] = []), f(n[u], [a])) : (delete n[u], e.push(u), r.push({ chain: o.concat([u]), id: u }))) } } } } return { type: "accepted", moduleId: t, outdatedModules: e, outdatedDependencies: n } } function f(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; -1 === t.indexOf(r) && t.push(r) } } n = n || {}; function o() { console.warn("[HMR] unexpected require(" + d.moduleId + ") to disposed module") } var s = {}, u = [], l = {}; for (var h in C) if (Object.prototype.hasOwnProperty.call(C, h)) { var d; i = B(h); var p = !1, g = !1, _ = !1, b = ""; switch ((d = C[h] ? a(i) : { type: "disposed", moduleId: h }).chain && (b = "\nUpdate propagation: " + d.chain.join(" -> ")), d.type) { case "self-declined": n.onDeclined && n.onDeclined(d), n.ignoreDeclined || (p = new Error("Aborted because of self decline: " + d.moduleId + b)); break; case "declined": n.onDeclined && n.onDeclined(d), n.ignoreDeclined || (p = new Error("Aborted because of declined dependency: " + d.moduleId + " in " + d.parentId + b)); break; case "unaccepted": n.onUnaccepted && n.onUnaccepted(d), n.ignoreUnaccepted || (p = new Error("Aborted because " + i + " is not accepted" + b)); break; case "accepted": n.onAccepted && n.onAccepted(d), g = !0; break; case "disposed": n.onDisposed && n.onDisposed(d), _ = !0; break; default: throw new Error("Unexception type " + d.type) }if (p) return P("abort"), Promise.reject(p); if (g) for (i in l[i] = C[i], f(u, d.outdatedModules), d.outdatedDependencies) Object.prototype.hasOwnProperty.call(d.outdatedDependencies, i) && (s[i] || (s[i] = []), f(s[i], d.outdatedDependencies[i])); _ && (f(u, [d.moduleId]), l[i] = o) } var m, y = []; for (e = 0; e < u.length; e++)i = u[e], U[i] && U[i].hot._selfAccepted && y.push({ module: i, errorHandler: U[i].hot._selfAccepted }); P("dispose"), Object.keys(M).forEach(function (t) { !1 === M[t] && function (t) { delete installedChunks[t] }(t) }); for (var v, w, E = u.slice(); 0 < E.length;)if (i = E.pop(), c = U[i]) { var T = {}, S = c.hot._disposeHandlers; for (r = 0; r < S.length; r++)(t = S[r])(T); for (N[i] = T, c.hot.active = !1, delete U[i], delete s[i], r = 0; r < c.children.length; r++) { var A = U[c.children[r]]; !A || 0 <= (m = A.parents.indexOf(i)) && A.parents.splice(m, 1) } } for (i in s) if (Object.prototype.hasOwnProperty.call(s, i) && (c = U[i])) for (w = s[i], r = 0; r < w.length; r++)v = w[r], 0 <= (m = c.children.indexOf(v)) && c.children.splice(m, 1); for (i in P("apply"), R = F, l) Object.prototype.hasOwnProperty.call(l, i) && (x[i] = l[i]); var k = null; for (i in s) if (Object.prototype.hasOwnProperty.call(s, i) && (c = U[i])) { w = s[i]; var I = []; for (e = 0; e < w.length; e++)if (v = w[e], t = c.hot._acceptedDependencies[v]) { if (-1 !== I.indexOf(t)) continue; I.push(t) } for (e = 0; e < I.length; e++) { t = I[e]; try { t(w) } catch (t) { n.onErrored && n.onErrored({ type: "accept-errored", moduleId: i, dependencyId: w[e], error: t }), n.ignoreErrored || k || (k = t) } } } for (e = 0; e < y.length; e++) { var O = y[e]; i = O.module, L = [i]; try { j(i) } catch (e) { if ("function" == typeof O.errorHandler) try { O.errorHandler(e) } catch (t) { n.onErrored && n.onErrored({ type: "self-accept-error-handler-errored", moduleId: i, error: t, originalError: e }), n.ignoreErrored || k || (k = t), k || (k = e) } else n.onErrored && n.onErrored({ type: "self-accept-errored", moduleId: i, error: e }), n.ignoreErrored || k || (k = e) } } return k ? (P("fail"), Promise.reject(k)) : (P("idle"), new Promise(function (t) { t(u) })) } var U = {}; function j(t) { if (U[t]) return U[t].exports; var e = U[t] = { i: t, l: !1, exports: {}, hot: function (t) { var r = { _acceptedDependencies: {}, _declinedDependencies: {}, _selfAccepted: !1, _selfDeclined: !1, _disposeHandlers: [], _main: a !== t, active: !0, accept: function (t, e) { if (void 0 === t) r._selfAccepted = !0; else if ("function" == typeof t) r._selfAccepted = t; else if ("object" == typeof t) for (var n = 0; n < t.length; n++)r._acceptedDependencies[t[n]] = e || function () { }; else r._acceptedDependencies[t] = e || function () { } }, decline: function (t) { if (void 0 === t) r._selfDeclined = !0; else if ("object" == typeof t) for (var e = 0; e < t.length; e++)r._declinedDependencies[t[e]] = !0; else r._declinedDependencies[t] = !0 }, dispose: function (t) { r._disposeHandlers.push(t) }, addDisposeHandler: function (t) { r._disposeHandlers.push(t) }, removeDisposeHandler: function (t) { var e = r._disposeHandlers.indexOf(t); 0 <= e && r._disposeHandlers.splice(e, 1) }, check: d, apply: _, status: function (t) { if (!t) return D; s.push(t) }, addStatusHandler: function (t) { s.push(t) }, removeStatusHandler: function (t) { var e = s.indexOf(t); 0 <= e && s.splice(e, 1) }, data: N[t] }; return a = void 0, r }(t), parents: (i = L, L = [], i), children: [] }; return x[t].call(e.exports, e, e.exports, o(t)), e.l = !0, e.exports } return j.m = x, j.c = U, j.d = function (t, e, n) { j.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }) }, j.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, j.t = function (e, t) { if (1 & t && (e = j(e)), 8 & t) return e; if (4 & t && "object" == typeof e && e && e.__esModule) return e; var n = Object.create(null); if (j.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var r in e) j.d(n, r, function (t) { return e[t] }.bind(null, r)); return n }, j.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return j.d(e, "a", e), e }, j.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, j.p = "", j.h = function () { return R }, o(52)(j.s = 52) }([function (t, e) { var n, r, i = t.exports = {}; function a() { throw new Error("setTimeout has not been defined") } function o() { throw new Error("clearTimeout has not been defined") } function s(e) { if (n === setTimeout) return setTimeout(e, 0); if ((n === a || !n) && setTimeout) return n = setTimeout, setTimeout(e, 0); try { return n(e, 0) } catch (t) { try { return n.call(null, e, 0) } catch (t) { return n.call(this, e, 0) } } } !function () { try { n = "function" == typeof setTimeout ? setTimeout : a } catch (t) { n = a } try { r = "function" == typeof clearTimeout ? clearTimeout : o } catch (t) { r = o } }(); var u, l = [], c = !1, f = -1; function h() { c && u && (c = !1, u.length ? l = u.concat(l) : f = -1, l.length && d()) } function d() { if (!c) { var t = s(h); c = !0; for (var e = l.length; e;) { for (u = l, l = []; ++f < e;)u && u[f].run(); f = -1, e = l.length } u = null, c = !1, function (e) { if (r === clearTimeout) return clearTimeout(e); if ((r === o || !r) && clearTimeout) return r = clearTimeout, clearTimeout(e); try { r(e) } catch (t) { try { return r.call(null, e) } catch (t) { return r.call(this, e) } } }(t) } } function p(t, e) { this.fun = t, this.array = e } function g() { } i.nextTick = function (t) { var e = new Array(arguments.length - 1); if (1 < arguments.length) for (var n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; l.push(new p(t, e)), 1 !== l.length || c || s(d) }, p.prototype.run = function () { this.fun.apply(null, this.array) }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = g, i.addListener = g, i.once = g, i.off = g, i.removeListener = g, i.removeAllListeners = g, i.emit = g, i.prependListener = g, i.prependOnceListener = g, i.listeners = function (t) { return [] }, i.binding = function (t) { throw new Error("process.binding is not supported") }, i.cwd = function () { return "/" }, i.chdir = function (t) { throw new Error("process.chdir is not supported") }, i.umask = function () { return 0 } }, function (t, M, B) {
    "use strict"; (function (t) {
      /*!
       * The buffer module from node.js, for the browser.
       *
       * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
       * @license  MIT
       */
      var r = B(25), a = B(26), o = B(14); function n() { return f.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function s(t, e) { if (n() < e) throw new RangeError("Invalid typed array length"); return f.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = f.prototype : (null === t && (t = new f(e)), t.length = e), t } function f(t, e, n) { if (!(f.TYPED_ARRAY_SUPPORT || this instanceof f)) return new f(t, e, n); if ("number" != typeof t) return i(this, t, e, n); if ("string" == typeof e) throw new Error("If encoding is specified then the first argument must be a string"); return l(this, t) } function i(t, e, n, r) { if ("number" == typeof e) throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function (t, e, n, r) { if (e.byteLength, n < 0 || e.byteLength < n) throw new RangeError("'offset' is out of bounds"); if (e.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds"); e = void 0 === n && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, n) : new Uint8Array(e, n, r); f.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = f.prototype : t = c(t, e); return t }(t, e, n, r) : "string" == typeof e ? function (t, e, n) { "string" == typeof n && "" !== n || (n = "utf8"); if (!f.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding'); var r = 0 | d(e, n), i = (t = s(t, r)).write(e, n); i !== r && (t = t.slice(0, i)); return t }(t, e, n) : function (t, e) { if (f.isBuffer(e)) { var n = 0 | h(e.length); return 0 === (t = s(t, n)).length || e.copy(t, 0, 0, n), t } if (e) { if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" != typeof e.length || function (t) { return t != t }(e.length) ? s(t, 0) : c(t, e); if ("Buffer" === e.type && o(e.data)) return c(t, e.data) } throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") }(t, e) } function u(t) { if ("number" != typeof t) throw new TypeError('"size" argument must be a number'); if (t < 0) throw new RangeError('"size" argument must not be negative') } function l(t, e) { if (u(e), t = s(t, e < 0 ? 0 : 0 | h(e)), !f.TYPED_ARRAY_SUPPORT) for (var n = 0; n < e; ++n)t[n] = 0; return t } function c(t, e) { var n = e.length < 0 ? 0 : 0 | h(e.length); t = s(t, n); for (var r = 0; r < n; r += 1)t[r] = 255 & e[r]; return t } function h(t) { if (t >= n()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n().toString(16) + " bytes"); return 0 | t } function d(t, e) { if (f.isBuffer(t)) return t.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength; "string" != typeof t && (t = "" + t); var n = t.length; if (0 === n) return 0; for (var r = !1; ;)switch (e) { case "ascii": case "latin1": case "binary": return n; case "utf8": case "utf-8": case void 0: return P(t).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * n; case "hex": return n >>> 1; case "base64": return C(t).length; default: if (r) return P(t).length; e = ("" + e).toLowerCase(), r = !0 } } function p(t, e, n) { var r = t[e]; t[e] = t[n], t[n] = r } function g(t, e, n, r, i) { if (0 === t.length) return -1; if ("string" == typeof n ? (r = n, n = 0) : 2147483647 < n ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = i ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) { if (i) return -1; n = t.length - 1 } else if (n < 0) { if (!i) return -1; n = 0 } if ("string" == typeof e && (e = f.from(e, r)), f.isBuffer(e)) return 0 === e.length ? -1 : _(t, e, n, r, i); if ("number" == typeof e) return e &= 255, f.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : _(t, [e], n, r, i); throw new TypeError("val must be string, number or Buffer") } function _(t, e, n, r, i) { var a, o = 1, s = t.length, u = e.length; if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) { if (t.length < 2 || e.length < 2) return -1; s /= o = 2, u /= 2, n /= 2 } function l(t, e) { return 1 === o ? t[e] : t.readUInt16BE(e * o) } if (i) { var c = -1; for (a = n; a < s; a++)if (l(t, a) === l(e, -1 === c ? 0 : a - c)) { if (-1 === c && (c = a), a - c + 1 === u) return c * o } else -1 !== c && (a -= a - c), c = -1 } else for (s < n + u && (n = s - u), a = n; 0 <= a; a--) { for (var f = !0, h = 0; h < u; h++)if (l(t, a + h) !== l(e, h)) { f = !1; break } if (f) return a } return -1 } function b(t, e, n, r) { n = Number(n) || 0; var i = t.length - n; r ? i < (r = Number(r)) && (r = i) : r = i; var a = e.length; if (a % 2 != 0) throw new TypeError("Invalid hex string"); a / 2 < r && (r = a / 2); for (var o = 0; o < r; ++o) { var s = parseInt(e.substr(2 * o, 2), 16); if (isNaN(s)) return o; t[n + o] = s } return o } function m(t, e, n, r) { return F(function (t) { for (var e = [], n = 0; n < t.length; ++n)e.push(255 & t.charCodeAt(n)); return e }(e), t, n, r) } function y(t, e, n) { return 0 === e && n === t.length ? r.fromByteArray(t) : r.fromByteArray(t.slice(e, n)) } function v(t, e, n) { n = Math.min(t.length, n); for (var r = [], i = e; i < n;) { var a, o, s, u, l = t[i], c = null, f = 239 < l ? 4 : 223 < l ? 3 : 191 < l ? 2 : 1; if (i + f <= n) switch (f) { case 1: l < 128 && (c = l); break; case 2: 128 != (192 & (a = t[i + 1])) || 127 < (u = (31 & l) << 6 | 63 & a) && (c = u); break; case 3: a = t[i + 1], o = t[i + 2], 128 != (192 & a) || 128 != (192 & o) || 2047 < (u = (15 & l) << 12 | (63 & a) << 6 | 63 & o) && (u < 55296 || 57343 < u) && (c = u); break; case 4: a = t[i + 1], o = t[i + 2], s = t[i + 3], 128 != (192 & a) || 128 != (192 & o) || 128 != (192 & s) || 65535 < (u = (15 & l) << 18 | (63 & a) << 12 | (63 & o) << 6 | 63 & s) && u < 1114112 && (c = u) }null === c ? (c = 65533, f = 1) : 65535 < c && (c -= 65536, r.push(c >>> 10 & 1023 | 55296), c = 56320 | 1023 & c), r.push(c), i += f } return function (t) { var e = t.length; if (e <= w) return String.fromCharCode.apply(String, t); var n = "", r = 0; for (; r < e;)n += String.fromCharCode.apply(String, t.slice(r, r += w)); return n }(r) } M.Buffer = f, M.SlowBuffer = function (t) { +t != t && (t = 0); return f.alloc(+t) }, M.INSPECT_MAX_BYTES = 50, f.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : function () { try { var t = new Uint8Array(1); return t.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength } catch (t) { return !1 } }(), M.kMaxLength = n(), f.poolSize = 8192, f._augment = function (t) { return t.__proto__ = f.prototype, t }, f.from = function (t, e, n) { return i(null, t, e, n) }, f.TYPED_ARRAY_SUPPORT && (f.prototype.__proto__ = Uint8Array.prototype, f.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && f[Symbol.species] === f && Object.defineProperty(f, Symbol.species, { value: null, configurable: !0 })), f.alloc = function (t, e, n) { return function (t, e, n, r) { return u(e), e <= 0 ? s(t, e) : void 0 !== n ? "string" == typeof r ? s(t, e).fill(n, r) : s(t, e).fill(n) : s(t, e) }(null, t, e, n) }, f.allocUnsafe = function (t) { return l(null, t) }, f.allocUnsafeSlow = function (t) { return l(null, t) }, f.isBuffer = function (t) { return !(null == t || !t._isBuffer) }, f.compare = function (t, e) { if (!f.isBuffer(t) || !f.isBuffer(e)) throw new TypeError("Arguments must be Buffers"); if (t === e) return 0; for (var n = t.length, r = e.length, i = 0, a = Math.min(n, r); i < a; ++i)if (t[i] !== e[i]) { n = t[i], r = e[i]; break } return n < r ? -1 : r < n ? 1 : 0 }, f.isEncoding = function (t) { switch (String(t).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, f.concat = function (t, e) { if (!o(t)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === t.length) return f.alloc(0); var n; if (void 0 === e) for (n = e = 0; n < t.length; ++n)e += t[n].length; var r = f.allocUnsafe(e), i = 0; for (n = 0; n < t.length; ++n) { var a = t[n]; if (!f.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers'); a.copy(r, i), i += a.length } return r }, f.byteLength = d, f.prototype._isBuffer = !0, f.prototype.swap16 = function () { var t = this.length; if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var e = 0; e < t; e += 2)p(this, e, e + 1); return this }, f.prototype.swap32 = function () { var t = this.length; if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var e = 0; e < t; e += 4)p(this, e, e + 3), p(this, e + 1, e + 2); return this }, f.prototype.swap64 = function () { var t = this.length; if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var e = 0; e < t; e += 8)p(this, e, e + 7), p(this, e + 1, e + 6), p(this, e + 2, e + 5), p(this, e + 3, e + 4); return this }, f.prototype.toString = function () { var t = 0 | this.length; return 0 == t ? "" : 0 === arguments.length ? v(this, 0, t) : function (t, e, n) { var r = !1; if ((void 0 === e || e < 0) && (e = 0), e > this.length) return ""; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return ""; if ((n >>>= 0) <= (e >>>= 0)) return ""; for (t || (t = "utf8"); ;)switch (t) { case "hex": return S(this, e, n); case "utf8": case "utf-8": return v(this, e, n); case "ascii": return E(this, e, n); case "latin1": case "binary": return T(this, e, n); case "base64": return y(this, e, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return A(this, e, n); default: if (r) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), r = !0 } }.apply(this, arguments) }, f.prototype.equals = function (t) { if (!f.isBuffer(t)) throw new TypeError("Argument must be a Buffer"); return this === t || 0 === f.compare(this, t) }, f.prototype.inspect = function () { var t = "", e = M.INSPECT_MAX_BYTES; return 0 < this.length && (t = this.toString("hex", 0, e).match(/.{2}/g).join(" "), this.length > e && (t += " ... ")), "<Buffer " + t + ">" }, f.prototype.compare = function (t, e, n, r, i) { if (!f.isBuffer(t)) throw new TypeError("Argument must be a Buffer"); if (void 0 === e && (e = 0), void 0 === n && (n = t ? t.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), e < 0 || n > t.length || r < 0 || i > this.length) throw new RangeError("out of range index"); if (i <= r && n <= e) return 0; if (i <= r) return -1; if (n <= e) return 1; if (this === t) return 0; for (var a = (i >>>= 0) - (r >>>= 0), o = (n >>>= 0) - (e >>>= 0), s = Math.min(a, o), u = this.slice(r, i), l = t.slice(e, n), c = 0; c < s; ++c)if (u[c] !== l[c]) { a = u[c], o = l[c]; break } return a < o ? -1 : o < a ? 1 : 0 }, f.prototype.includes = function (t, e, n) { return -1 !== this.indexOf(t, e, n) }, f.prototype.indexOf = function (t, e, n) { return g(this, t, e, n, !0) }, f.prototype.lastIndexOf = function (t, e, n) { return g(this, t, e, n, !1) }, f.prototype.write = function (t, e, n, r) { if (void 0 === e) r = "utf8", n = this.length, e = 0; else if (void 0 === n && "string" == typeof e) r = e, n = this.length, e = 0; else { if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); e |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0) } var i = this.length - e; if ((void 0 === n || i < n) && (n = i), 0 < t.length && (n < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds"); r || (r = "utf8"); for (var a, o, s, u, l, c, f, h, d, p = !1; ;)switch (r) { case "hex": return b(this, t, e, n); case "utf8": case "utf-8": return h = e, d = n, F(P(t, (f = this).length - h), f, h, d); case "ascii": return m(this, t, e, n); case "latin1": case "binary": return m(this, t, e, n); case "base64": return u = this, l = e, c = n, F(C(t), u, l, c); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return o = e, s = n, F(function (t, e) { for (var n, r, i, a = [], o = 0; o < t.length && !((e -= 2) < 0); ++o)n = t.charCodeAt(o), r = n >> 8, i = n % 256, a.push(i), a.push(r); return a }(t, (a = this).length - o), a, o, s); default: if (p) throw new TypeError("Unknown encoding: " + r); r = ("" + r).toLowerCase(), p = !0 } }, f.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; var w = 4096; function E(t, e, n) { var r = ""; n = Math.min(t.length, n); for (var i = e; i < n; ++i)r += String.fromCharCode(127 & t[i]); return r } function T(t, e, n) { var r = ""; n = Math.min(t.length, n); for (var i = e; i < n; ++i)r += String.fromCharCode(t[i]); return r } function S(t, e, n) { var r = t.length; (!e || e < 0) && (e = 0), (!n || n < 0 || r < n) && (n = r); for (var i = "", a = e; a < n; ++a)i += D(t[a]); return i } function A(t, e, n) { for (var r = t.slice(e, n), i = "", a = 0; a < r.length; a += 2)i += String.fromCharCode(r[a] + 256 * r[a + 1]); return i } function k(t, e, n) { if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint"); if (n < t + e) throw new RangeError("Trying to access beyond buffer length") } function I(t, e, n, r, i, a) { if (!f.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (i < e || e < a) throw new RangeError('"value" argument is out of bounds'); if (n + r > t.length) throw new RangeError("Index out of range") } function O(t, e, n, r) { e < 0 && (e = 65535 + e + 1); for (var i = 0, a = Math.min(t.length - n, 2); i < a; ++i)t[n + i] = (e & 255 << 8 * (r ? i : 1 - i)) >>> 8 * (r ? i : 1 - i) } function x(t, e, n, r) { e < 0 && (e = 4294967295 + e + 1); for (var i = 0, a = Math.min(t.length - n, 4); i < a; ++i)t[n + i] = e >>> 8 * (r ? i : 3 - i) & 255 } function R(t, e, n, r, i, a) { if (n + r > t.length) throw new RangeError("Index out of range"); if (n < 0) throw new RangeError("Index out of range") } function N(t, e, n, r, i) { return i || R(t, 0, n, 4), a.write(t, e, n, r, 23, 4), n + 4 } function L(t, e, n, r, i) { return i || R(t, 0, n, 8), a.write(t, e, n, r, 52, 8), n + 8 } f.prototype.slice = function (t, e) { var n, r = this.length; if ((t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : r < t && (t = r), (e = void 0 === e ? r : ~~e) < 0 ? (e += r) < 0 && (e = 0) : r < e && (e = r), e < t && (e = t), f.TYPED_ARRAY_SUPPORT) (n = this.subarray(t, e)).__proto__ = f.prototype; else { var i = e - t; n = new f(i, void 0); for (var a = 0; a < i; ++a)n[a] = this[a + t] } return n }, f.prototype.readUIntLE = function (t, e, n) { t |= 0, e |= 0, n || k(t, e, this.length); for (var r = this[t], i = 1, a = 0; ++a < e && (i *= 256);)r += this[t + a] * i; return r }, f.prototype.readUIntBE = function (t, e, n) { t |= 0, e |= 0, n || k(t, e, this.length); for (var r = this[t + --e], i = 1; 0 < e && (i *= 256);)r += this[t + --e] * i; return r }, f.prototype.readUInt8 = function (t, e) { return e || k(t, 1, this.length), this[t] }, f.prototype.readUInt16LE = function (t, e) { return e || k(t, 2, this.length), this[t] | this[t + 1] << 8 }, f.prototype.readUInt16BE = function (t, e) { return e || k(t, 2, this.length), this[t] << 8 | this[t + 1] }, f.prototype.readUInt32LE = function (t, e) { return e || k(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] }, f.prototype.readUInt32BE = function (t, e) { return e || k(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]) }, f.prototype.readIntLE = function (t, e, n) { t |= 0, e |= 0, n || k(t, e, this.length); for (var r = this[t], i = 1, a = 0; ++a < e && (i *= 256);)r += this[t + a] * i; return (i *= 128) <= r && (r -= Math.pow(2, 8 * e)), r }, f.prototype.readIntBE = function (t, e, n) { t |= 0, e |= 0, n || k(t, e, this.length); for (var r = e, i = 1, a = this[t + --r]; 0 < r && (i *= 256);)a += this[t + --r] * i; return (i *= 128) <= a && (a -= Math.pow(2, 8 * e)), a }, f.prototype.readInt8 = function (t, e) { return e || k(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t] }, f.prototype.readInt16LE = function (t, e) { e || k(t, 2, this.length); var n = this[t] | this[t + 1] << 8; return 32768 & n ? 4294901760 | n : n }, f.prototype.readInt16BE = function (t, e) { e || k(t, 2, this.length); var n = this[t + 1] | this[t] << 8; return 32768 & n ? 4294901760 | n : n }, f.prototype.readInt32LE = function (t, e) { return e || k(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24 }, f.prototype.readInt32BE = function (t, e) { return e || k(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3] }, f.prototype.readFloatLE = function (t, e) { return e || k(t, 4, this.length), a.read(this, t, !0, 23, 4) }, f.prototype.readFloatBE = function (t, e) { return e || k(t, 4, this.length), a.read(this, t, !1, 23, 4) }, f.prototype.readDoubleLE = function (t, e) { return e || k(t, 8, this.length), a.read(this, t, !0, 52, 8) }, f.prototype.readDoubleBE = function (t, e) { return e || k(t, 8, this.length), a.read(this, t, !1, 52, 8) }, f.prototype.writeUIntLE = function (t, e, n, r) { (t = +t, e |= 0, n |= 0, r) || I(this, t, e, n, Math.pow(2, 8 * n) - 1, 0); var i = 1, a = 0; for (this[e] = 255 & t; ++a < n && (i *= 256);)this[e + a] = t / i & 255; return e + n }, f.prototype.writeUIntBE = function (t, e, n, r) { (t = +t, e |= 0, n |= 0, r) || I(this, t, e, n, Math.pow(2, 8 * n) - 1, 0); var i = n - 1, a = 1; for (this[e + i] = 255 & t; 0 <= --i && (a *= 256);)this[e + i] = t / a & 255; return e + n }, f.prototype.writeUInt8 = function (t, e, n) { return t = +t, e |= 0, n || I(this, t, e, 1, 255, 0), f.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1 }, f.prototype.writeUInt16LE = function (t, e, n) { return t = +t, e |= 0, n || I(this, t, e, 2, 65535, 0), f.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : O(this, t, e, !0), e + 2 }, f.prototype.writeUInt16BE = function (t, e, n) { return t = +t, e |= 0, n || I(this, t, e, 2, 65535, 0), f.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : O(this, t, e, !1), e + 2 }, f.prototype.writeUInt32LE = function (t, e, n) { return t = +t, e |= 0, n || I(this, t, e, 4, 4294967295, 0), f.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : x(this, t, e, !0), e + 4 }, f.prototype.writeUInt32BE = function (t, e, n) { return t = +t, e |= 0, n || I(this, t, e, 4, 4294967295, 0), f.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : x(this, t, e, !1), e + 4 }, f.prototype.writeIntLE = function (t, e, n, r) { if (t = +t, e |= 0, !r) { var i = Math.pow(2, 8 * n - 1); I(this, t, e, n, i - 1, -i) } var a = 0, o = 1, s = 0; for (this[e] = 255 & t; ++a < n && (o *= 256);)t < 0 && 0 === s && 0 !== this[e + a - 1] && (s = 1), this[e + a] = (t / o >> 0) - s & 255; return e + n }, f.prototype.writeIntBE = function (t, e, n, r) { if (t = +t, e |= 0, !r) { var i = Math.pow(2, 8 * n - 1); I(this, t, e, n, i - 1, -i) } var a = n - 1, o = 1, s = 0; for (this[e + a] = 255 & t; 0 <= --a && (o *= 256);)t < 0 && 0 === s && 0 !== this[e + a + 1] && (s = 1), this[e + a] = (t / o >> 0) - s & 255; return e + n }, f.prototype.writeInt8 = function (t, e, n) { return t = +t, e |= 0, n || I(this, t, e, 1, 127, -128), f.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1 }, f.prototype.writeInt16LE = function (t, e, n) { return t = +t, e |= 0, n || I(this, t, e, 2, 32767, -32768), f.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : O(this, t, e, !0), e + 2 }, f.prototype.writeInt16BE = function (t, e, n) { return t = +t, e |= 0, n || I(this, t, e, 2, 32767, -32768), f.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : O(this, t, e, !1), e + 2 }, f.prototype.writeInt32LE = function (t, e, n) { return t = +t, e |= 0, n || I(this, t, e, 4, 2147483647, -2147483648), f.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : x(this, t, e, !0), e + 4 }, f.prototype.writeInt32BE = function (t, e, n) { return t = +t, e |= 0, n || I(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), f.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : x(this, t, e, !1), e + 4 }, f.prototype.writeFloatLE = function (t, e, n) { return N(this, t, e, !0, n) }, f.prototype.writeFloatBE = function (t, e, n) { return N(this, t, e, !1, n) }, f.prototype.writeDoubleLE = function (t, e, n) { return L(this, t, e, !0, n) }, f.prototype.writeDoubleBE = function (t, e, n) { return L(this, t, e, !1, n) }, f.prototype.copy = function (t, e, n, r) { if (n || (n = 0), r || 0 === r || (r = this.length), e >= t.length && (e = t.length), e || (e = 0), 0 < r && r < n && (r = n), r === n) return 0; if (0 === t.length || 0 === this.length) return 0; if (e < 0) throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds"); if (r < 0) throw new RangeError("sourceEnd out of bounds"); r > this.length && (r = this.length), t.length - e < r - n && (r = t.length - e + n); var i, a = r - n; if (this === t && n < e && e < r) for (i = a - 1; 0 <= i; --i)t[i + e] = this[i + n]; else if (a < 1e3 || !f.TYPED_ARRAY_SUPPORT) for (i = 0; i < a; ++i)t[i + e] = this[i + n]; else Uint8Array.prototype.set.call(t, this.subarray(n, n + a), e); return a }, f.prototype.fill = function (t, e, n, r) { if ("string" == typeof t) { if ("string" == typeof e ? (r = e, e = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === t.length) { var i = t.charCodeAt(0); i < 256 && (t = i) } if (void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string"); if ("string" == typeof r && !f.isEncoding(r)) throw new TypeError("Unknown encoding: " + r) } else "number" == typeof t && (t &= 255); if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index"); if (n <= e) return this; var a; if (e >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" == typeof t) for (a = e; a < n; ++a)this[a] = t; else { var o = f.isBuffer(t) ? t : P(new f(t, r).toString()), s = o.length; for (a = 0; a < n - e; ++a)this[a + e] = o[a % s] } return this }; var e = /[^+\/0-9A-Za-z-_]/g; function D(t) { return t < 16 ? "0" + t.toString(16) : t.toString(16) } function P(t, e) { var n; e = e || 1 / 0; for (var r = t.length, i = null, a = [], o = 0; o < r; ++o) { if (55295 < (n = t.charCodeAt(o)) && n < 57344) { if (!i) { if (56319 < n) { -1 < (e -= 3) && a.push(239, 191, 189); continue } if (o + 1 === r) { -1 < (e -= 3) && a.push(239, 191, 189); continue } i = n; continue } if (n < 56320) { -1 < (e -= 3) && a.push(239, 191, 189), i = n; continue } n = 65536 + (i - 55296 << 10 | n - 56320) } else !i || -1 < (e -= 3) && a.push(239, 191, 189); if (i = null, n < 128) { if ((e -= 1) < 0) break; a.push(n) } else if (n < 2048) { if ((e -= 2) < 0) break; a.push(n >> 6 | 192, 63 & n | 128) } else if (n < 65536) { if ((e -= 3) < 0) break; a.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128) } else { if (!(n < 1114112)) throw new Error("Invalid code point"); if ((e -= 4) < 0) break; a.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128) } } return a } function C(t) { return r.toByteArray(function (t) { if ((t = function (t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") }(t).replace(e, "")).length < 2) return ""; for (; t.length % 4 != 0;)t += "="; return t }(t)) } function F(t, e, n, r) { for (var i = 0; i < r && !(i + n >= e.length || i >= t.length); ++i)e[i + n] = t[i]; return i }
    }).call(this, B(2))
  }, function (t, e) { var n; n = function () { return this }(); try { n = n || new Function("return this")() } catch (t) { "object" == typeof window && (n = window) } t.exports = n }, function (t, e) { "function" == typeof Object.create ? t.exports = function (t, e) { t.super_ = e, t.prototype = Object.create(e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }) } : t.exports = function (t, e) { t.super_ = e; function n() { } n.prototype = e.prototype, t.prototype = new n, t.prototype.constructor = t } }, function (t, e, n) { "use strict"; var r = n(7), i = Object.keys || function (t) { var e = []; for (var n in t) e.push(n); return e }; t.exports = f; var a = n(5); a.inherits = n(3); var o = n(16), s = n(12); a.inherits(f, o); for (var u = i(s.prototype), l = 0; l < u.length; l++) { var c = u[l]; f.prototype[c] || (f.prototype[c] = s.prototype[c]) } function f(t) { if (!(this instanceof f)) return new f(t); o.call(this, t), s.call(this, t), t && !1 === t.readable && (this.readable = !1), t && !1 === t.writable && (this.writable = !1), this.allowHalfOpen = !0, t && !1 === t.allowHalfOpen && (this.allowHalfOpen = !1), this.once("end", h) } function h() { this.allowHalfOpen || this._writableState.ended || r.nextTick(d, this) } function d(t) { t.end() } Object.defineProperty(f.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }), Object.defineProperty(f.prototype, "destroyed", { get: function () { return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed) }, set: function (t) { void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t) } }), f.prototype._destroy = function (t, e) { this.push(null), this.end(), r.nextTick(e, t) } }, function (t, n, e) { (function (t) { function e(t) { return Object.prototype.toString.call(t) } n.isArray = function (t) { return Array.isArray ? Array.isArray(t) : "[object Array]" === e(t) }, n.isBoolean = function (t) { return "boolean" == typeof t }, n.isNull = function (t) { return null === t }, n.isNullOrUndefined = function (t) { return null == t }, n.isNumber = function (t) { return "number" == typeof t }, n.isString = function (t) { return "string" == typeof t }, n.isSymbol = function (t) { return "symbol" == typeof t }, n.isUndefined = function (t) { return void 0 === t }, n.isRegExp = function (t) { return "[object RegExp]" === e(t) }, n.isObject = function (t) { return "object" == typeof t && null !== t }, n.isDate = function (t) { return "[object Date]" === e(t) }, n.isError = function (t) { return "[object Error]" === e(t) || t instanceof Error }, n.isFunction = function (t) { return "function" == typeof t }, n.isPrimitive = function (t) { return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || void 0 === t }, n.isBuffer = t.isBuffer }).call(this, e(1).Buffer) }, function (t, l, e) { (function (i) { function a(t, e) { for (var n = 0, r = t.length - 1; 0 <= r; r--) { var i = t[r]; "." === i ? t.splice(r, 1) : ".." === i ? (t.splice(r, 1), n++) : n && (t.splice(r, 1), n--) } if (e) for (; n--; n)t.unshift(".."); return t } function o(t) { return e.exec(t).slice(1) } var e = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/; function s(t, e) { if (t.filter) return t.filter(e); for (var n = [], r = 0; r < t.length; r++)e(t[r], r, t) && n.push(t[r]); return n } l.resolve = function () { for (var t = "", e = !1, n = arguments.length - 1; -1 <= n && !e; n--) { var r = 0 <= n ? arguments[n] : i.cwd(); if ("string" != typeof r) throw new TypeError("Arguments to path.resolve must be strings"); r && (t = r + "/" + t, e = "/" === r.charAt(0)) } return (e ? "/" : "") + (t = a(s(t.split("/"), function (t) { return !!t }), !e).join("/")) || "." }, l.normalize = function (t) { var e = l.isAbsolute(t), n = "/" === r(t, -1); return (t = a(s(t.split("/"), function (t) { return !!t }), !e).join("/")) || e || (t = "."), t && n && (t += "/"), (e ? "/" : "") + t }, l.isAbsolute = function (t) { return "/" === t.charAt(0) }, l.join = function () { var t = Array.prototype.slice.call(arguments, 0); return l.normalize(s(t, function (t, e) { if ("string" != typeof t) throw new TypeError("Arguments to path.join must be strings"); return t }).join("/")) }, l.relative = function (t, e) { function n(t) { for (var e = 0; e < t.length && "" === t[e]; e++); for (var n = t.length - 1; 0 <= n && "" === t[n]; n--); return n < e ? [] : t.slice(e, n - e + 1) } t = l.resolve(t).substr(1), e = l.resolve(e).substr(1); for (var r = n(t.split("/")), i = n(e.split("/")), a = Math.min(r.length, i.length), o = a, s = 0; s < a; s++)if (r[s] !== i[s]) { o = s; break } var u = []; for (s = o; s < r.length; s++)u.push(".."); return (u = u.concat(i.slice(o))).join("/") }, l.sep = "/", l.delimiter = ":", l.dirname = function (t) { var e = o(t), n = e[0], r = e[1]; return n || r ? (r && (r = r.substr(0, r.length - 1)), n + r) : "." }, l.basename = function (t, e) { var n = o(t)[2]; return e && n.substr(-1 * e.length) === e && (n = n.substr(0, n.length - e.length)), n }, l.extname = function (t) { return o(t)[3] }; var r = "b" === "ab".substr(-1) ? function (t, e, n) { return t.substr(e, n) } : function (t, e, n) { return e < 0 && (e = t.length + e), t.substr(e, n) } }).call(this, e(0)) }, function (t, e, n) { "use strict"; (function (s) { !s.version || 0 === s.version.indexOf("v0.") || 0 === s.version.indexOf("v1.") && 0 !== s.version.indexOf("v1.8.") ? t.exports = { nextTick: function (t, e, n, r) { if ("function" != typeof t) throw new TypeError('"callback" argument must be a function'); var i, a, o = arguments.length; switch (o) { case 0: case 1: return s.nextTick(t); case 2: return s.nextTick(function () { t.call(null, e) }); case 3: return s.nextTick(function () { t.call(null, e, n) }); case 4: return s.nextTick(function () { t.call(null, e, n, r) }); default: for (i = new Array(o - 1), a = 0; a < i.length;)i[a++] = arguments[a]; return s.nextTick(function () { t.apply(null, i) }) } } } : t.exports = s }).call(this, n(0)) }, function (t, e, n) { var r = n(1), i = r.Buffer; function a(t, e) { for (var n in t) e[n] = t[n] } function o(t, e, n) { return i(t, e, n) } i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = r : (a(r, e), e.Buffer = o), a(i, o), o.from = function (t, e, n) { if ("number" == typeof t) throw new TypeError("Argument must not be a number"); return i(t, e, n) }, o.alloc = function (t, e, n) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); var r = i(t); return void 0 !== e ? "string" == typeof n ? r.fill(e, n) : r.fill(e) : r.fill(0), r }, o.allocUnsafe = function (t) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); return i(t) }, o.allocUnsafeSlow = function (t) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); return r.SlowBuffer(t) } }, function (t, e, n) { "use strict"; var r = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array; e.assign = function (t) { for (var e, n, r = Array.prototype.slice.call(arguments, 1); r.length;) { var i = r.shift(); if (i) { if ("object" != typeof i) throw new TypeError(i + "must be non-object"); for (var a in i) e = i, n = a, Object.prototype.hasOwnProperty.call(e, n) && (t[a] = i[a]) } } return t }, e.shrinkBuf = function (t, e) { return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t) }; var i = { arraySet: function (t, e, n, r, i) { if (e.subarray && t.subarray) t.set(e.subarray(n, n + r), i); else for (var a = 0; a < r; a++)t[i + a] = e[n + a] }, flattenChunks: function (t) { var e, n, r, i, a, o; for (e = r = 0, n = t.length; e < n; e++)r += t[e].length; for (o = new Uint8Array(r), e = i = 0, n = t.length; e < n; e++)a = t[e], o.set(a, i), i += a.length; return o } }, a = { arraySet: function (t, e, n, r, i) { for (var a = 0; a < r; a++)t[i + a] = e[n + a] }, flattenChunks: function (t) { return [].concat.apply([], t) } }; e.setTyped = function (t) { t ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, i)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, a)) }, e.setTyped(r) }, function (t, e, n) { "use strict"; var r, i = "object" == typeof Reflect ? Reflect : null, c = i && "function" == typeof i.apply ? i.apply : function (t, e, n) { return Function.prototype.apply.call(t, e, n) }; r = i && "function" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function (t) { return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t)) } : function (t) { return Object.getOwnPropertyNames(t) }; var a = Number.isNaN || function (t) { return t != t }; function o() { o.init.call(this) } ((t.exports = o).EventEmitter = o).prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0; var s = 10; function u(t) { return void 0 === t._maxListeners ? o.defaultMaxListeners : t._maxListeners } function l(t, e, n, r) { var i, a, o; if ("function" != typeof n) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n); if (void 0 === (a = t._events) ? (a = t._events = Object.create(null), t._eventsCount = 0) : (void 0 !== a.newListener && (t.emit("newListener", e, n.listener ? n.listener : n), a = t._events), o = a[e]), void 0 === o) o = a[e] = n, ++t._eventsCount; else if ("function" == typeof o ? o = a[e] = r ? [n, o] : [o, n] : r ? o.unshift(n) : o.push(n), 0 < (i = u(t)) && o.length > i && !o.warned) { o.warned = !0; var s = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit"); s.name = "MaxListenersExceededWarning", s.emitter = t, s.type = e, s.count = o.length, function (t) { console && console.warn && console.warn(t) }(s) } return t } function f(t, e, n) { var r = { fired: !1, wrapFn: void 0, target: t, type: e, listener: n }, i = function () { for (var t = [], e = 0; e < arguments.length; e++)t.push(arguments[e]); this.fired || (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, c(this.listener, this.target, t)) }.bind(r); return i.listener = n, r.wrapFn = i } function h(t, e, n) { var r = t._events; if (void 0 === r) return []; var i = r[e]; return void 0 === i ? [] : "function" == typeof i ? n ? [i.listener || i] : [i] : n ? function (t) { for (var e = new Array(t.length), n = 0; n < e.length; ++n)e[n] = t[n].listener || t[n]; return e }(i) : p(i, i.length) } function d(t) { var e = this._events; if (void 0 !== e) { var n = e[t]; if ("function" == typeof n) return 1; if (void 0 !== n) return n.length } return 0 } function p(t, e) { for (var n = new Array(e), r = 0; r < e; ++r)n[r] = t[r]; return n } Object.defineProperty(o, "defaultMaxListeners", { enumerable: !0, get: function () { return s }, set: function (t) { if ("number" != typeof t || t < 0 || a(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + "."); s = t } }), o.init = function () { void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }, o.prototype.setMaxListeners = function (t) { if ("number" != typeof t || t < 0 || a(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + "."); return this._maxListeners = t, this }, o.prototype.getMaxListeners = function () { return u(this) }, o.prototype.emit = function (t) { for (var e = [], n = 1; n < arguments.length; n++)e.push(arguments[n]); var r = "error" === t, i = this._events; if (void 0 !== i) r = r && void 0 === i.error; else if (!r) return !1; if (r) { var a; if (0 < e.length && (a = e[0]), a instanceof Error) throw a; var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : "")); throw o.context = a, o } var s = i[t]; if (void 0 === s) return !1; if ("function" == typeof s) c(s, this, e); else { var u = s.length, l = p(s, u); for (n = 0; n < u; ++n)c(l[n], this, e) } return !0 }, o.prototype.on = o.prototype.addListener = function (t, e) { return l(this, t, e, !1) }, o.prototype.prependListener = function (t, e) { return l(this, t, e, !0) }, o.prototype.once = function (t, e) { if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e); return this.on(t, f(this, t, e)), this }, o.prototype.prependOnceListener = function (t, e) { if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e); return this.prependListener(t, f(this, t, e)), this }, o.prototype.off = o.prototype.removeListener = function (t, e) { var n, r, i, a, o; if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e); if (void 0 === (r = this._events)) return this; if (void 0 === (n = r[t])) return this; if (n === e || n.listener === e) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[t], r.removeListener && this.emit("removeListener", t, n.listener || e)); else if ("function" != typeof n) { for (i = -1, a = n.length - 1; 0 <= a; a--)if (n[a] === e || n[a].listener === e) { o = n[a].listener, i = a; break } if (i < 0) return this; 0 === i ? n.shift() : function (t, e) { for (; e + 1 < t.length; e++)t[e] = t[e + 1]; t.pop() }(n, i), 1 === n.length && (r[t] = n[0]), void 0 !== r.removeListener && this.emit("removeListener", t, o || e) } return this }, o.prototype.removeAllListeners = function (t) { var e, n, r; if (void 0 === (n = this._events)) return this; if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[t]), this; if (0 === arguments.length) { var i, a = Object.keys(n); for (r = 0; r < a.length; ++r)"removeListener" !== (i = a[r]) && this.removeAllListeners(i); return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this } if ("function" == typeof (e = n[t])) this.removeListener(t, e); else if (void 0 !== e) for (r = e.length - 1; 0 <= r; r--)this.removeListener(t, e[r]); return this }, o.prototype.listeners = function (t) { return h(this, t, !0) }, o.prototype.rawListeners = function (t) { return h(this, t, !1) }, o.listenerCount = function (t, e) { return "function" == typeof t.listenerCount ? t.listenerCount(e) : d.call(t, e) }, o.prototype.listenerCount = d, o.prototype.eventNames = function () { return 0 < this._eventsCount ? r(this._events) : [] } }, function (t, e, n) { (((e = t.exports = n(16)).Stream = e).Readable = e).Writable = n(12), e.Duplex = n(4), e.Transform = n(19), e.PassThrough = n(34) }, function (T, t, S) { "use strict"; (function (t, e, n) { var s = S(7); function f(t) { var e = this; this.next = null, this.entry = null, this.finish = function () { !function (t, e, n) { var r = t.entry; t.entry = null; for (; r;) { var i = r.callback; e.pendingcb-- , i(n), r = r.next } e.corkedRequestsFree ? e.corkedRequestsFree.next = t : e.corkedRequestsFree = t }(e, t) } } T.exports = _; var u, l = !t.browser && -1 < ["v0.10", "v0.9."].indexOf(t.version.slice(0, 5)) ? e : s.nextTick; _.WritableState = g; var r = S(5); r.inherits = S(3); var i = { deprecate: S(33) }, a = S(17), c = S(8).Buffer, o = n.Uint8Array || function () { }; var h, d = S(18); function p() { } function g(t, e) { u = u || S(4), t = t || {}; var n = e instanceof u; this.objectMode = !!t.objectMode, n && (this.objectMode = this.objectMode || !!t.writableObjectMode); var r = t.highWaterMark, i = t.writableHighWaterMark, a = this.objectMode ? 16 : 16384; this.highWaterMark = r || 0 === r ? r : n && (i || 0 === i) ? i : a, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1; var o = (this.destroyed = !1) === t.decodeStrings; this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (t) { !function (t, e) { var n = t._writableState, r = n.sync, i = n.writecb; if (function (t) { t.writing = !1, t.writecb = null, t.length -= t.writelen, t.writelen = 0 }(n), e) !function (t, e, n, r, i) { --e.pendingcb, n ? (s.nextTick(i, r), s.nextTick(E, t, e), t._writableState.errorEmitted = !0, t.emit("error", r)) : (i(r), t._writableState.errorEmitted = !0, t.emit("error", r), E(t, e)) }(t, n, r, e, i); else { var a = v(n); a || n.corked || n.bufferProcessing || !n.bufferedRequest || y(t, n), r ? l(m, t, n, a, i) : m(t, n, a, i) } }(e, t) }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new f(this) } function _(t) { if (u = u || S(4), !(h.call(_, this) || this instanceof u)) return new _(t); this._writableState = new g(t, this), this.writable = !0, t && ("function" == typeof t.write && (this._write = t.write), "function" == typeof t.writev && (this._writev = t.writev), "function" == typeof t.destroy && (this._destroy = t.destroy), "function" == typeof t.final && (this._final = t.final)), a.call(this) } function b(t, e, n, r, i, a, o) { e.writelen = r, e.writecb = o, e.writing = !0, e.sync = !0, n ? t._writev(i, e.onwrite) : t._write(i, a, e.onwrite), e.sync = !1 } function m(t, e, n, r) { n || function (t, e) { 0 === e.length && e.needDrain && (e.needDrain = !1, t.emit("drain")) }(t, e), e.pendingcb-- , r(), E(t, e) } function y(t, e) { e.bufferProcessing = !0; var n = e.bufferedRequest; if (t._writev && n && n.next) { var r = e.bufferedRequestCount, i = new Array(r), a = e.corkedRequestsFree; a.entry = n; for (var o = 0, s = !0; n;)(i[o] = n).isBuf || (s = !1), n = n.next, o += 1; i.allBuffers = s, b(t, e, !0, e.length, i, "", a.finish), e.pendingcb++ , e.lastBufferedRequest = null, a.next ? (e.corkedRequestsFree = a.next, a.next = null) : e.corkedRequestsFree = new f(e), e.bufferedRequestCount = 0 } else { for (; n;) { var u = n.chunk, l = n.encoding, c = n.callback; if (b(t, e, !1, e.objectMode ? 1 : u.length, u, l, c), n = n.next, e.bufferedRequestCount-- , e.writing) break } null === n && (e.lastBufferedRequest = null) } e.bufferedRequest = n, e.bufferProcessing = !1 } function v(t) { return t.ending && 0 === t.length && null === t.bufferedRequest && !t.finished && !t.writing } function w(e, n) { e._final(function (t) { n.pendingcb-- , t && e.emit("error", t), n.prefinished = !0, e.emit("prefinish"), E(e, n) }) } function E(t, e) { var n = v(e); return n && (function (t, e) { e.prefinished || e.finalCalled || ("function" == typeof t._final ? (e.pendingcb++ , e.finalCalled = !0, s.nextTick(w, t, e)) : (e.prefinished = !0, t.emit("prefinish"))) }(t, e), 0 === e.pendingcb && (e.finished = !0, t.emit("finish"))), n } r.inherits(_, a), g.prototype.getBuffer = function () { for (var t = this.bufferedRequest, e = []; t;)e.push(t), t = t.next; return e }, function () { try { Object.defineProperty(g.prototype, "buffer", { get: i.deprecate(function () { return this.getBuffer() }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") }) } catch (t) { } }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (h = Function.prototype[Symbol.hasInstance], Object.defineProperty(_, Symbol.hasInstance, { value: function (t) { return !!h.call(this, t) || this === _ && (t && t._writableState instanceof g) } })) : h = function (t) { return t instanceof this }, _.prototype.pipe = function () { this.emit("error", new Error("Cannot pipe, not readable")) }, _.prototype.write = function (t, e, n) { var r = this._writableState, i = !1, a = !r.objectMode && function (t) { return c.isBuffer(t) || t instanceof o }(t); return a && !c.isBuffer(t) && (t = function (t) { return c.from(t) }(t)), "function" == typeof e && (n = e, e = null), a ? e = "buffer" : e || (e = r.defaultEncoding), "function" != typeof n && (n = p), r.ended ? function (t, e) { var n = new Error("write after end"); t.emit("error", n), s.nextTick(e, n) }(this, n) : (a || function (t, e, n, r) { var i = !0, a = !1; return null === n ? a = new TypeError("May not write null values to stream") : "string" == typeof n || void 0 === n || e.objectMode || (a = new TypeError("Invalid non-string/buffer chunk")), a && (t.emit("error", a), s.nextTick(r, a), i = !1), i }(this, r, t, n)) && (r.pendingcb++ , i = function (t, e, n, r, i, a) { if (!n) { var o = function (t, e, n) { t.objectMode || !1 === t.decodeStrings || "string" != typeof e || (e = c.from(e, n)); return e }(e, r, i); r !== o && (n = !0, i = "buffer", r = o) } var s = e.objectMode ? 1 : r.length; e.length += s; var u = e.length < e.highWaterMark; u || (e.needDrain = !0); if (e.writing || e.corked) { var l = e.lastBufferedRequest; e.lastBufferedRequest = { chunk: r, encoding: i, isBuf: n, callback: a, next: null }, l ? l.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1 } else b(t, e, !1, s, r, i, a); return u }(this, r, a, t, e, n)), i }, _.prototype.cork = function () { this._writableState.corked++ }, _.prototype.uncork = function () { var t = this._writableState; t.corked && (t.corked-- , t.writing || t.corked || t.finished || t.bufferProcessing || !t.bufferedRequest || y(this, t)) }, _.prototype.setDefaultEncoding = function (t) { if ("string" == typeof t && (t = t.toLowerCase()), !(-1 < ["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase()))) throw new TypeError("Unknown encoding: " + t); return this._writableState.defaultEncoding = t, this }, Object.defineProperty(_.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }), _.prototype._write = function (t, e, n) { n(new Error("_write() is not implemented")) }, _.prototype._writev = null, _.prototype.end = function (t, e, n) { var r = this._writableState; "function" == typeof t ? (n = t, e = t = null) : "function" == typeof e && (n = e, e = null), null != t && this.write(t, e), r.corked && (r.corked = 1, this.uncork()), r.ending || r.finished || function (t, e, n) { e.ending = !0, E(t, e), n && (e.finished ? s.nextTick(n) : t.once("finish", n)); e.ended = !0, t.writable = !1 }(this, r, n) }, Object.defineProperty(_.prototype, "destroyed", { get: function () { return void 0 !== this._writableState && this._writableState.destroyed }, set: function (t) { this._writableState && (this._writableState.destroyed = t) } }), _.prototype.destroy = d.destroy, _.prototype._undestroy = d.undestroy, _.prototype._destroy = function (t, e) { this.end(), e(t) } }).call(this, S(0), S(31).setImmediate, S(2)) }, function (t, e, n) { "use strict"; var r = n(8).Buffer, i = r.isEncoding || function (t) { switch ((t = "" + t) && t.toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": case "raw": return !0; default: return !1 } }; function a(t) { var e; switch (this.encoding = function (t) { var e = function (t) { if (!t) return "utf8"; for (var e; ;)switch (t) { case "utf8": case "utf-8": return "utf8"; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return "utf16le"; case "latin1": case "binary": return "latin1"; case "base64": case "ascii": case "hex": return t; default: if (e) return; t = ("" + t).toLowerCase(), e = !0 } }(t); if ("string" != typeof e && (r.isEncoding === i || !i(t))) throw new Error("Unknown encoding: " + t); return e || t }(t), this.encoding) { case "utf16le": this.text = u, this.end = l, e = 4; break; case "utf8": this.fillLast = s, e = 4; break; case "base64": this.text = c, this.end = f, e = 3; break; default: return this.write = h, void (this.end = d) }this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r.allocUnsafe(e) } function o(t) { return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2 } function s(t) { var e = this.lastTotal - this.lastNeed, n = function (t, e, n) { if (128 != (192 & e[0])) return t.lastNeed = 0, "�"; if (1 < t.lastNeed && 1 < e.length) { if (128 != (192 & e[1])) return t.lastNeed = 1, "�"; if (2 < t.lastNeed && 2 < e.length && 128 != (192 & e[2])) return t.lastNeed = 2, "�" } }(this, t); return void 0 !== n ? n : this.lastNeed <= t.length ? (t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t.copy(this.lastChar, e, 0, t.length), void (this.lastNeed -= t.length)) } function u(t, e) { if ((t.length - e) % 2 != 0) return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1); var n = t.toString("utf16le", e); if (n) { var r = n.charCodeAt(n.length - 1); if (55296 <= r && r <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], n.slice(0, -1) } return n } function l(t) { var e = t && t.length ? this.write(t) : ""; if (this.lastNeed) { var n = this.lastTotal - this.lastNeed; return e + this.lastChar.toString("utf16le", 0, n) } return e } function c(t, e) { var n = (t.length - e) % 3; return 0 == n ? t.toString("base64", e) : (this.lastNeed = 3 - n, this.lastTotal = 3, 1 == n ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - n)) } function f(t) { var e = t && t.length ? this.write(t) : ""; return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e } function h(t) { return t.toString(this.encoding) } function d(t) { return t && t.length ? this.write(t) : "" } (e.StringDecoder = a).prototype.write = function (t) { if (0 === t.length) return ""; var e, n; if (this.lastNeed) { if (void 0 === (e = this.fillLast(t))) return ""; n = this.lastNeed, this.lastNeed = 0 } else n = 0; return n < t.length ? e ? e + this.text(t, n) : this.text(t, n) : e || "" }, a.prototype.end = function (t) { var e = t && t.length ? this.write(t) : ""; return this.lastNeed ? e + "�" : e }, a.prototype.text = function (t, e) { var n = function (t, e, n) { var r = e.length - 1; if (r < n) return 0; var i = o(e[r]); if (0 <= i) return 0 < i && (t.lastNeed = i - 1), i; if (--r < n || -2 === i) return 0; if (0 <= (i = o(e[r]))) return 0 < i && (t.lastNeed = i - 2), i; if (--r < n || -2 === i) return 0; if (0 <= (i = o(e[r]))) return 0 < i && (2 === i ? i = 0 : t.lastNeed = i - 3), i; return 0 }(this, t, e); if (!this.lastNeed) return t.toString("utf8", e); this.lastTotal = n; var r = t.length - (n - this.lastNeed); return t.copy(this.lastChar, 0, r), t.toString("utf8", e, r) }, a.prototype.fillLast = function (t) { if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal); t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length } }, function (t, e) { var n = {}.toString; t.exports = Array.isArray || function (t) { return "[object Array]" == n.call(t) } }, function (t, e, n) { t.exports = r; var c = n(10).EventEmitter; function r() { c.call(this) } n(3)(r, c), r.Readable = n(11), r.Writable = n(35), r.Duplex = n(36), r.Transform = n(37), r.PassThrough = n(38), (r.Stream = r).prototype.pipe = function (e, t) { var n = this; function r(t) { !e.writable || !1 === e.write(t) && n.pause && n.pause() } function i() { n.readable && n.resume && n.resume() } n.on("data", r), e.on("drain", i), e._isStdio || t && !1 === t.end || (n.on("end", o), n.on("close", s)); var a = !1; function o() { a || (a = !0, e.end()) } function s() { a || (a = !0, "function" == typeof e.destroy && e.destroy()) } function u(t) { if (l(), 0 === c.listenerCount(this, "error")) throw t } function l() { n.removeListener("data", r), e.removeListener("drain", i), n.removeListener("end", o), n.removeListener("close", s), n.removeListener("error", u), e.removeListener("error", u), n.removeListener("end", l), n.removeListener("close", l), e.removeListener("close", l) } return n.on("error", u), e.on("error", u), n.on("end", l), n.on("close", l), e.on("close", l), e.emit("pipe", n), e } }, function (D, t, P) { "use strict"; (function (t, g) { var _ = P(7); D.exports = h; var o, b = P(14); h.ReadableState = a; function m(t, e) { return t.listeners(e).length } P(10).EventEmitter; var i = P(17), s = P(8).Buffer, u = t.Uint8Array || function () { }; var e = P(5); e.inherits = P(3); var n = P(28), y = void 0; y = n && n.debuglog ? n.debuglog("stream") : function () { }; var l, c = P(29), r = P(18); e.inherits(h, i); var f = ["error", "close", "destroy", "pause", "resume"]; function a(t, e) { t = t || {}; var n = e instanceof (o = o || P(4)); this.objectMode = !!t.objectMode, n && (this.objectMode = this.objectMode || !!t.readableObjectMode); var r = t.highWaterMark, i = t.readableHighWaterMark, a = this.objectMode ? 16 : 16384; this.highWaterMark = r || 0 === r ? r : n && (i || 0 === i) ? i : a, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new c, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (l || (l = P(13).StringDecoder), this.decoder = new l(t.encoding), this.encoding = t.encoding) } function h(t) { if (o = o || P(4), !(this instanceof h)) return new h(t); this._readableState = new a(t, this), this.readable = !0, t && ("function" == typeof t.read && (this._read = t.read), "function" == typeof t.destroy && (this._destroy = t.destroy)), i.call(this) } function d(t, e, n, r, i) { var a, o = t._readableState; null === e ? (o.reading = !1, function (t, e) { if (e.ended) return; if (e.decoder) { var n = e.decoder.end(); n && n.length && (e.buffer.push(n), e.length += e.objectMode ? 1 : n.length) } e.ended = !0, E(t) }(t, o)) : (i || (a = function (t, e) { var n; (function (t) { return s.isBuffer(t) || t instanceof u })(e) || "string" == typeof e || void 0 === e || t.objectMode || (n = new TypeError("Invalid non-string/buffer chunk")); return n }(o, e)), a ? t.emit("error", a) : o.objectMode || e && 0 < e.length ? ("string" == typeof e || o.objectMode || Object.getPrototypeOf(e) === s.prototype || (e = function (t) { return s.from(t) }(e)), r ? o.endEmitted ? t.emit("error", new Error("stream.unshift() after end event")) : p(t, o, e, !0) : o.ended ? t.emit("error", new Error("stream.push() after EOF")) : (o.reading = !1, o.decoder && !n ? (e = o.decoder.write(e), o.objectMode || 0 !== e.length ? p(t, o, e, !1) : S(t, o)) : p(t, o, e, !1))) : r || (o.reading = !1)); return function (t) { return !t.ended && (t.needReadable || t.length < t.highWaterMark || 0 === t.length) }(o) } function p(t, e, n, r) { e.flowing && 0 === e.length && !e.sync ? (t.emit("data", n), t.read(0)) : (e.length += e.objectMode ? 1 : n.length, r ? e.buffer.unshift(n) : e.buffer.push(n), e.needReadable && E(t)), S(t, e) } Object.defineProperty(h.prototype, "destroyed", { get: function () { return void 0 !== this._readableState && this._readableState.destroyed }, set: function (t) { this._readableState && (this._readableState.destroyed = t) } }), h.prototype.destroy = r.destroy, h.prototype._undestroy = r.undestroy, h.prototype._destroy = function (t, e) { this.push(null), e(t) }, h.prototype.push = function (t, e) { var n, r = this._readableState; return r.objectMode ? n = !0 : "string" == typeof t && ((e = e || r.defaultEncoding) !== r.encoding && (t = s.from(t, e), e = ""), n = !0), d(this, t, e, !1, n) }, h.prototype.unshift = function (t) { return d(this, t, null, !0, !1) }, h.prototype.isPaused = function () { return !1 === this._readableState.flowing }, h.prototype.setEncoding = function (t) { return l || (l = P(13).StringDecoder), this._readableState.decoder = new l(t), this._readableState.encoding = t, this }; var v = 8388608; function w(t, e) { return t <= 0 || 0 === e.length && e.ended ? 0 : e.objectMode ? 1 : t != t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = function (t) { return v <= t ? t = v : (t-- , t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t }(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = !0, 0)) } function E(t) { var e = t._readableState; e.needReadable = !1, e.emittedReadable || (y("emitReadable", e.flowing), e.emittedReadable = !0, e.sync ? _.nextTick(T, t) : T(t)) } function T(t) { y("emit readable"), t.emit("readable"), O(t) } function S(t, e) { e.readingMore || (e.readingMore = !0, _.nextTick(A, t, e)) } function A(t, e) { for (var n = e.length; !e.reading && !e.flowing && !e.ended && e.length < e.highWaterMark && (y("maybeReadMore read 0"), t.read(0), n !== e.length);)n = e.length; e.readingMore = !1 } function k(t) { y("readable nexttick read 0"), t.read(0) } function I(t, e) { e.reading || (y("resume read 0"), t.read(0)), e.resumeScheduled = !1, e.awaitDrain = 0, t.emit("resume"), O(t), e.flowing && !e.reading && t.read(0) } function O(t) { var e = t._readableState; for (y("flow", e.flowing); e.flowing && null !== t.read();); } function x(t, e) { return 0 === e.length ? null : (e.objectMode ? n = e.buffer.shift() : !t || t >= e.length ? (n = e.decoder ? e.buffer.join("") : 1 === e.buffer.length ? e.buffer.head.data : e.buffer.concat(e.length), e.buffer.clear()) : n = function (t, e, n) { var r; t < e.head.data.length ? (r = e.head.data.slice(0, t), e.head.data = e.head.data.slice(t)) : r = t === e.head.data.length ? e.shift() : n ? function (t, e) { var n = e.head, r = 1, i = n.data; t -= i.length; for (; n = n.next;) { var a = n.data, o = t > a.length ? a.length : t; if (o === a.length ? i += a : i += a.slice(0, t), 0 === (t -= o)) { o === a.length ? (++r, n.next ? e.head = n.next : e.head = e.tail = null) : (e.head = n).data = a.slice(o); break } ++r } return e.length -= r, i }(t, e) : function (t, e) { var n = s.allocUnsafe(t), r = e.head, i = 1; r.data.copy(n), t -= r.data.length; for (; r = r.next;) { var a = r.data, o = t > a.length ? a.length : t; if (a.copy(n, n.length - t, 0, o), 0 === (t -= o)) { o === a.length ? (++i, r.next ? e.head = r.next : e.head = e.tail = null) : (e.head = r).data = a.slice(o); break } ++i } return e.length -= i, n }(t, e); return r }(t, e.buffer, e.decoder), n); var n } function R(t) { var e = t._readableState; if (0 < e.length) throw new Error('"endReadable()" called on non-empty stream'); e.endEmitted || (e.ended = !0, _.nextTick(N, e, t)) } function N(t, e) { t.endEmitted || 0 !== t.length || (t.endEmitted = !0, e.readable = !1, e.emit("end")) } function L(t, e) { for (var n = 0, r = t.length; n < r; n++)if (t[n] === e) return n; return -1 } h.prototype.read = function (t) { y("read", t), t = parseInt(t, 10); var e = this._readableState, n = t; if (0 !== t && (e.emittedReadable = !1), 0 === t && e.needReadable && (e.length >= e.highWaterMark || e.ended)) return y("read: emitReadable", e.length, e.ended), 0 === e.length && e.ended ? R(this) : E(this), null; if (0 === (t = w(t, e)) && e.ended) return 0 === e.length && R(this), null; var r, i = e.needReadable; return y("need readable", i), (0 === e.length || e.length - t < e.highWaterMark) && y("length less than watermark", i = !0), e.ended || e.reading ? y("reading or ended", i = !1) : i && (y("do read"), e.reading = !0, e.sync = !0, 0 === e.length && (e.needReadable = !0), this._read(e.highWaterMark), e.sync = !1, e.reading || (t = w(n, e))), null === (r = 0 < t ? x(t, e) : null) ? (e.needReadable = !0, t = 0) : e.length -= t, 0 === e.length && (e.ended || (e.needReadable = !0), n !== t && e.ended && R(this)), null !== r && this.emit("data", r), r }, h.prototype._read = function (t) { this.emit("error", new Error("_read() is not implemented")) }, h.prototype.pipe = function (n, t) { var r = this, i = this._readableState; switch (i.pipesCount) { case 0: i.pipes = n; break; case 1: i.pipes = [i.pipes, n]; break; default: i.pipes.push(n) }i.pipesCount += 1, y("pipe count=%d opts=%j", i.pipesCount, t); var e = (!t || !1 !== t.end) && n !== g.stdout && n !== g.stderr ? o : p; function a(t, e) { y("onunpipe"), t !== r || e && !1 === e.hasUnpiped && (e.hasUnpiped = !0, y("cleanup"), n.removeListener("close", h), n.removeListener("finish", d), n.removeListener("drain", s), n.removeListener("error", f), n.removeListener("unpipe", a), r.removeListener("end", o), r.removeListener("end", p), r.removeListener("data", c), u = !0, !i.awaitDrain || n._writableState && !n._writableState.needDrain || s()) } function o() { y("onend"), n.end() } i.endEmitted ? _.nextTick(e) : r.once("end", e), n.on("unpipe", a); var s = function (e) { return function () { var t = e._readableState; y("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain-- , 0 === t.awaitDrain && m(e, "data") && (t.flowing = !0, O(e)) } }(r); n.on("drain", s); var u = !1; var l = !1; function c(t) { y("ondata"), (l = !1) !== n.write(t) || l || ((1 === i.pipesCount && i.pipes === n || 1 < i.pipesCount && -1 !== L(i.pipes, n)) && !u && (y("false write response, pause", r._readableState.awaitDrain), r._readableState.awaitDrain++ , l = !0), r.pause()) } function f(t) { y("onerror", t), p(), n.removeListener("error", f), 0 === m(n, "error") && n.emit("error", t) } function h() { n.removeListener("finish", d), p() } function d() { y("onfinish"), n.removeListener("close", h), p() } function p() { y("unpipe"), r.unpipe(n) } return r.on("data", c), function (t, e, n) { if ("function" == typeof t.prependListener) return t.prependListener(e, n); t._events && t._events[e] ? b(t._events[e]) ? t._events[e].unshift(n) : t._events[e] = [n, t._events[e]] : t.on(e, n) }(n, "error", f), n.once("close", h), n.once("finish", d), n.emit("pipe", r), i.flowing || (y("pipe resume"), r.resume()), n }, h.prototype.unpipe = function (t) { var e = this._readableState, n = { hasUnpiped: !1 }; if (0 === e.pipesCount) return this; if (1 === e.pipesCount) return t && t !== e.pipes || (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = !1, t && t.emit("unpipe", this, n)), this; if (!t) { var r = e.pipes, i = e.pipesCount; e.pipes = null, e.pipesCount = 0, e.flowing = !1; for (var a = 0; a < i; a++)r[a].emit("unpipe", this, n); return this } var o = L(e.pipes, t); return -1 === o || (e.pipes.splice(o, 1), e.pipesCount -= 1, 1 === e.pipesCount && (e.pipes = e.pipes[0]), t.emit("unpipe", this, n)), this }, h.prototype.addListener = h.prototype.on = function (t, e) { var n = i.prototype.on.call(this, t, e); if ("data" === t) !1 !== this._readableState.flowing && this.resume(); else if ("readable" === t) { var r = this._readableState; r.endEmitted || r.readableListening || (r.readableListening = r.needReadable = !0, r.emittedReadable = !1, r.reading ? r.length && E(this) : _.nextTick(k, this)) } return n }, h.prototype.resume = function () { var t = this._readableState; return t.flowing || (y("resume"), t.flowing = !0, function (t, e) { e.resumeScheduled || (e.resumeScheduled = !0, _.nextTick(I, t, e)) }(this, t)), this }, h.prototype.pause = function () { return y("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (y("pause"), this._readableState.flowing = !1, this.emit("pause")), this }, h.prototype.wrap = function (e) { var n = this, r = this._readableState, i = !1; for (var t in e.on("end", function () { if (y("wrapped end"), r.decoder && !r.ended) { var t = r.decoder.end(); t && t.length && n.push(t) } n.push(null) }), e.on("data", function (t) { (y("wrapped data"), r.decoder && (t = r.decoder.write(t)), r.objectMode && null == t) || (r.objectMode || t && t.length) && (n.push(t) || (i = !0, e.pause())) }), e) void 0 === this[t] && "function" == typeof e[t] && (this[t] = function (t) { return function () { return e[t].apply(e, arguments) } }(t)); for (var a = 0; a < f.length; a++)e.on(f[a], this.emit.bind(this, f[a])); return this._read = function (t) { y("wrapped _read", t), i && (i = !1, e.resume()) }, this }, Object.defineProperty(h.prototype, "readableHighWaterMark", { enumerable: !1, get: function () { return this._readableState.highWaterMark } }), h._fromList = x }).call(this, P(2), P(0)) }, function (t, e, n) { t.exports = n(10).EventEmitter }, function (t, e, n) { "use strict"; var a = n(7); function o(t, e) { t.emit("error", e) } t.exports = { destroy: function (t, e) { var n = this, r = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed; return r || i ? e ? e(t) : !t || this._writableState && this._writableState.errorEmitted || a.nextTick(o, this, t) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, function (t) { !e && t ? (a.nextTick(o, n, t), n._writableState && (n._writableState.errorEmitted = !0)) : e && e(t) })), this }, undestroy: function () { this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1) } } }, function (t, e, n) { "use strict"; t.exports = a; var r = n(4), i = n(5); function a(t) { if (!(this instanceof a)) return new a(t); r.call(this, t), this._transformState = { afterTransform: function (t, e) { var n = this._transformState; n.transforming = !1; var r = n.writecb; if (!r) return this.emit("error", new Error("write callback called multiple times")); n.writechunk = null, (n.writecb = null) != e && this.push(e), r(t); var i = this._readableState; i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark) }.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && ("function" == typeof t.transform && (this._transform = t.transform), "function" == typeof t.flush && (this._flush = t.flush)), this.on("prefinish", o) } function o() { var n = this; "function" == typeof this._flush ? this._flush(function (t, e) { s(n, t, e) }) : s(this, null, null) } function s(t, e, n) { if (e) return t.emit("error", e); if (null != n && t.push(n), t._writableState.length) throw new Error("Calling transform done when ws.length != 0"); if (t._transformState.transforming) throw new Error("Calling transform done when still transforming"); return t.push(null) } i.inherits = n(3), i.inherits(a, r), a.prototype.push = function (t, e) { return this._transformState.needTransform = !1, r.prototype.push.call(this, t, e) }, a.prototype._transform = function (t, e, n) { throw new Error("_transform() is not implemented") }, a.prototype._write = function (t, e, n) { var r = this._transformState; if (r.writecb = n, r.writechunk = t, r.writeencoding = e, !r.transforming) { var i = this._readableState; (r.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark) } }, a.prototype._read = function (t) { var e = this._transformState; null !== e.writechunk && e.writecb && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0 }, a.prototype._destroy = function (t, e) { var n = this; r.prototype._destroy.call(this, t, function (t) { e(t), n.emit("close") }) } }, function (w, t, E) {
    "use strict"; (function (e) {
      /*!
       * The buffer module from node.js, for the browser.
       *
       * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
       * @license  MIT
       */
      function a(t, e) { if (t === e) return 0; for (var n = t.length, r = e.length, i = 0, a = Math.min(n, r); i < a; ++i)if (t[i] !== e[i]) { n = t[i], r = e[i]; break } return n < r ? -1 : r < n ? 1 : 0 } function o(t) { return e.Buffer && "function" == typeof e.Buffer.isBuffer ? e.Buffer.isBuffer(t) : !(null == t || !t._isBuffer) } var c = E(21), r = Object.prototype.hasOwnProperty, f = Array.prototype.slice, n = "foo" === function () { }.name; function s(t) { return Object.prototype.toString.call(t) } function u(t) { return !o(t) && ("function" == typeof e.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t) : !!t && (t instanceof DataView || !!(t.buffer && t.buffer instanceof ArrayBuffer)))) } var l = w.exports = t, i = /\s*function\s+([^\(\s]*)\s*/; function h(t) { if (c.isFunction(t)) { if (n) return t.name; var e = t.toString().match(i); return e && e[1] } } function d(t, e) { return "string" == typeof t ? t.length < e ? t : t.slice(0, e) : t } function p(t) { if (n || !c.isFunction(t)) return c.inspect(t); var e = h(t); return "[Function" + (e ? ": " + e : "") + "]" } function g(t, e, n, r, i) { throw new l.AssertionError({ message: n, actual: t, expected: e, operator: r, stackStartFunction: i }) } function t(t, e) { t || g(t, !0, e, "==", l.ok) } function _(t, e, n, r) { if (t === e) return !0; if (o(t) && o(e)) return 0 === a(t, e); if (c.isDate(t) && c.isDate(e)) return t.getTime() === e.getTime(); if (c.isRegExp(t) && c.isRegExp(e)) return t.source === e.source && t.global === e.global && t.multiline === e.multiline && t.lastIndex === e.lastIndex && t.ignoreCase === e.ignoreCase; if (null !== t && "object" == typeof t || null !== e && "object" == typeof e) { if (u(t) && u(e) && s(t) === s(e) && !(t instanceof Float32Array || t instanceof Float64Array)) return 0 === a(new Uint8Array(t.buffer), new Uint8Array(e.buffer)); if (o(t) !== o(e)) return !1; var i = (r = r || { actual: [], expected: [] }).actual.indexOf(t); return -1 !== i && i === r.expected.indexOf(e) || (r.actual.push(t), r.expected.push(e), function (t, e, n, r) { if (null == t || null == e) return !1; if (c.isPrimitive(t) || c.isPrimitive(e)) return t === e; if (n && Object.getPrototypeOf(t) !== Object.getPrototypeOf(e)) return !1; var i = b(t), a = b(e); if (i && !a || !i && a) return !1; if (i) return t = f.call(t), e = f.call(e), _(t, e, n); var o, s, u = v(t), l = v(e); if (u.length !== l.length) return !1; for (u.sort(), l.sort(), s = u.length - 1; 0 <= s; s--)if (u[s] !== l[s]) return !1; for (s = u.length - 1; 0 <= s; s--)if (o = u[s], !_(t[o], e[o], n, r)) return !1; return !0 }(t, e, n, r)) } return n ? t === e : t == e } function b(t) { return "[object Arguments]" == Object.prototype.toString.call(t) } function m(t, e) { if (!t || !e) return !1; if ("[object RegExp]" == Object.prototype.toString.call(e)) return e.test(t); try { if (t instanceof e) return !0 } catch (t) { } return !Error.isPrototypeOf(e) && !0 === e.call({}, t) } function y(t, e, n, r) { var i; if ("function" != typeof e) throw new TypeError('"block" argument must be a function'); "string" == typeof n && (r = n, n = null), i = function (t) { var e; try { t() } catch (t) { e = t } return e }(e), r = (n && n.name ? " (" + n.name + ")." : ".") + (r ? " " + r : "."), t && !i && g(i, n, "Missing expected exception" + r); var a = "string" == typeof r, o = !t && i && !n; if ((!t && c.isError(i) && a && m(i, n) || o) && g(i, n, "Got unwanted exception" + r), t && i && n && !m(i, n) || !t && i) throw i } l.AssertionError = function (t) { this.name = "AssertionError", this.actual = t.actual, this.expected = t.expected, this.operator = t.operator, t.message ? (this.message = t.message, this.generatedMessage = !1) : (this.message = function (t) { return d(p(t.actual), 128) + " " + t.operator + " " + d(p(t.expected), 128) }(this), this.generatedMessage = !0); var e = t.stackStartFunction || g; if (Error.captureStackTrace) Error.captureStackTrace(this, e); else { var n = new Error; if (n.stack) { var r = n.stack, i = h(e), a = r.indexOf("\n" + i); if (0 <= a) { var o = r.indexOf("\n", a + 1); r = r.substring(o + 1) } this.stack = r } } }, c.inherits(l.AssertionError, Error), l.fail = g, l.ok = t, l.equal = function (t, e, n) { t != e && g(t, e, n, "==", l.equal) }, l.notEqual = function (t, e, n) { t == e && g(t, e, n, "!=", l.notEqual) }, l.deepEqual = function (t, e, n) { _(t, e, !1) || g(t, e, n, "deepEqual", l.deepEqual) }, l.deepStrictEqual = function (t, e, n) { _(t, e, !0) || g(t, e, n, "deepStrictEqual", l.deepStrictEqual) }, l.notDeepEqual = function (t, e, n) { _(t, e, !1) && g(t, e, n, "notDeepEqual", l.notDeepEqual) }, l.notDeepStrictEqual = function t(e, n, r) { _(e, n, !0) && g(e, n, r, "notDeepStrictEqual", t) }, l.strictEqual = function (t, e, n) { t !== e && g(t, e, n, "===", l.strictEqual) }, l.notStrictEqual = function (t, e, n) { t === e && g(t, e, n, "!==", l.notStrictEqual) }, l.throws = function (t, e, n) { y(!0, t, e, n) }, l.doesNotThrow = function (t, e, n) { y(!1, t, e, n) }, l.ifError = function (t) { if (t) throw t }; var v = Object.keys || function (t) { var e = []; for (var n in t) r.call(t, n) && e.push(n); return e }
    }).call(this, E(2))
  }, function (t, O, x) { (function (o) { var e = Object.getOwnPropertyDescriptors || function (t) { for (var e = Object.keys(t), n = {}, r = 0; r < e.length; r++)n[e[r]] = Object.getOwnPropertyDescriptor(t, e[r]); return n }, s = /%[sdj%]/g; O.format = function (t) { if (!y(t)) { for (var e = [], n = 0; n < arguments.length; n++)e.push(u(arguments[n])); return e.join(" ") } n = 1; for (var r = arguments, i = r.length, a = String(t).replace(s, function (t) { if ("%%" === t) return "%"; if (i <= n) return t; switch (t) { case "%s": return String(r[n++]); case "%d": return Number(r[n++]); case "%j": try { return JSON.stringify(r[n++]) } catch (t) { return "[Circular]" } default: return t } }), o = r[n]; n < i; o = r[++n])b(o) || !l(o) ? a += " " + o : a += " " + u(o); return a }, O.deprecate = function (t, e) { if (void 0 !== o && !0 === o.noDeprecation) return t; if (void 0 === o) return function () { return O.deprecate(t, e).apply(this, arguments) }; var n = !1; return function () { if (!n) { if (o.throwDeprecation) throw new Error(e); o.traceDeprecation ? console.trace(e) : console.error(e), n = !0 } return t.apply(this, arguments) } }; var t, r = {}; function u(t, e) { var n = { seen: [], stylize: a }; return 3 <= arguments.length && (n.depth = arguments[2]), 4 <= arguments.length && (n.colors = arguments[3]), _(e) ? n.showHidden = e : e && O._extend(n, e), v(n.showHidden) && (n.showHidden = !1), v(n.depth) && (n.depth = 2), v(n.colors) && (n.colors = !1), v(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = i), h(n, t, n.depth) } function i(t, e) { var n = u.styles[e]; return n ? "[" + u.colors[n][0] + "m" + t + "[" + u.colors[n][1] + "m" : t } function a(t, e) { return t } function h(e, n, r) { if (e.customInspect && n && S(n.inspect) && n.inspect !== O.inspect && (!n.constructor || n.constructor.prototype !== n)) { var t = n.inspect(r, e); return y(t) || (t = h(e, t, r)), t } var i = function (t, e) { if (v(e)) return t.stylize("undefined", "undefined"); if (y(e)) { var n = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'"; return t.stylize(n, "string") } if (m(e)) return t.stylize("" + e, "number"); if (_(e)) return t.stylize("" + e, "boolean"); if (b(e)) return t.stylize("null", "null") }(e, n); if (i) return i; var a = Object.keys(n), o = function (t) { var n = {}; return t.forEach(function (t, e) { n[t] = !0 }), n }(a); if (e.showHidden && (a = Object.getOwnPropertyNames(n)), T(n) && (0 <= a.indexOf("message") || 0 <= a.indexOf("description"))) return d(n); if (0 === a.length) { if (S(n)) { var s = n.name ? ": " + n.name : ""; return e.stylize("[Function" + s + "]", "special") } if (w(n)) return e.stylize(RegExp.prototype.toString.call(n), "regexp"); if (E(n)) return e.stylize(Date.prototype.toString.call(n), "date"); if (T(n)) return d(n) } var u, l = "", c = !1, f = ["{", "}"]; (g(n) && (c = !0, f = ["[", "]"]), S(n)) && (l = " [Function" + (n.name ? ": " + n.name : "") + "]"); return w(n) && (l = " " + RegExp.prototype.toString.call(n)), E(n) && (l = " " + Date.prototype.toUTCString.call(n)), T(n) && (l = " " + d(n)), 0 !== a.length || c && 0 != n.length ? r < 0 ? w(n) ? e.stylize(RegExp.prototype.toString.call(n), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(n), u = c ? function (e, n, r, i, t) { for (var a = [], o = 0, s = n.length; o < s; ++o)A(n, String(o)) ? a.push(p(e, n, r, i, String(o), !0)) : a.push(""); return t.forEach(function (t) { t.match(/^\d+$/) || a.push(p(e, n, r, i, t, !0)) }), a }(e, n, r, o, a) : a.map(function (t) { return p(e, n, r, o, t, c) }), e.seen.pop(), function (t, e, n) { if (60 < t.reduce(function (t, e) { return 0, 0 <= e.indexOf("\n") && 0, t + e.replace(/\u001b\[\d\d?m/g, "").length + 1 }, 0)) return n[0] + ("" === e ? "" : e + "\n ") + " " + t.join(",\n  ") + " " + n[1]; return n[0] + e + " " + t.join(", ") + " " + n[1] }(u, l, f)) : f[0] + l + f[1] } function d(t) { return "[" + Error.prototype.toString.call(t) + "]" } function p(t, e, n, r, i, a) { var o, s, u; if ((u = Object.getOwnPropertyDescriptor(e, i) || { value: e[i] }).get ? s = u.set ? t.stylize("[Getter/Setter]", "special") : t.stylize("[Getter]", "special") : u.set && (s = t.stylize("[Setter]", "special")), A(r, i) || (o = "[" + i + "]"), s || (t.seen.indexOf(u.value) < 0 ? -1 < (s = b(n) ? h(t, u.value, null) : h(t, u.value, n - 1)).indexOf("\n") && (s = a ? s.split("\n").map(function (t) { return "  " + t }).join("\n").substr(2) : "\n" + s.split("\n").map(function (t) { return "   " + t }).join("\n")) : s = t.stylize("[Circular]", "special")), v(o)) { if (a && i.match(/^\d+$/)) return s; o = (o = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o = o.substr(1, o.length - 2), t.stylize(o, "name")) : (o = o.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), t.stylize(o, "string")) } return o + ": " + s } function g(t) { return Array.isArray(t) } function _(t) { return "boolean" == typeof t } function b(t) { return null === t } function m(t) { return "number" == typeof t } function y(t) { return "string" == typeof t } function v(t) { return void 0 === t } function w(t) { return l(t) && "[object RegExp]" === n(t) } function l(t) { return "object" == typeof t && null !== t } function E(t) { return l(t) && "[object Date]" === n(t) } function T(t) { return l(t) && ("[object Error]" === n(t) || t instanceof Error) } function S(t) { return "function" == typeof t } function n(t) { return Object.prototype.toString.call(t) } function c(t) { return t < 10 ? "0" + t.toString(10) : t.toString(10) } O.debuglog = function (e) { if (v(t) && (t = o.env.NODE_DEBUG || ""), e = e.toUpperCase(), !r[e]) if (new RegExp("\\b" + e + "\\b", "i").test(t)) { var n = o.pid; r[e] = function () { var t = O.format.apply(O, arguments); console.error("%s %d: %s", e, n, t) } } else r[e] = function () { }; return r[e] }, (O.inspect = u).colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, u.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, O.isArray = g, O.isBoolean = _, O.isNull = b, O.isNullOrUndefined = function (t) { return null == t }, O.isNumber = m, O.isString = y, O.isSymbol = function (t) { return "symbol" == typeof t }, O.isUndefined = v, O.isRegExp = w, O.isObject = l, O.isDate = E, O.isError = T, O.isFunction = S, O.isPrimitive = function (t) { return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || void 0 === t }, O.isBuffer = x(42); var f = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; function A(t, e) { return Object.prototype.hasOwnProperty.call(t, e) } O.log = function () { console.log("%s - %s", function () { var t = new Date, e = [c(t.getHours()), c(t.getMinutes()), c(t.getSeconds())].join(":"); return [t.getDate(), f[t.getMonth()], e].join(" ") }(), O.format.apply(O, arguments)) }, O.inherits = x(3), O._extend = function (t, e) { if (!e || !l(e)) return t; for (var n = Object.keys(e), r = n.length; r--;)t[n[r]] = e[n[r]]; return t }; var k = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0; function I(t, e) { if (!t) { var n = new Error("Promise was rejected with a falsy value"); n.reason = t, t = n } return e(t) } O.promisify = function (a) { if ("function" != typeof a) throw new TypeError('The "original" argument must be of type Function'); if (k && a[k]) { var t; if ("function" != typeof (t = a[k])) throw new TypeError('The "util.promisify.custom" argument must be of type Function'); return Object.defineProperty(t, k, { value: t, enumerable: !1, writable: !1, configurable: !0 }), t } function t() { for (var n, r, t = new Promise(function (t, e) { n = t, r = e }), e = [], i = 0; i < arguments.length; i++)e.push(arguments[i]); e.push(function (t, e) { t ? r(t) : n(e) }); try { a.apply(this, e) } catch (t) { r(t) } return t } return Object.setPrototypeOf(t, Object.getPrototypeOf(a)), k && Object.defineProperty(t, k, { value: t, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(t, e(a)) }, O.promisify.custom = k, O.callbackify = function (a) { if ("function" != typeof a) throw new TypeError('The "original" argument must be of type Function'); function t() { for (var t = [], e = 0; e < arguments.length; e++)t.push(arguments[e]); var n = t.pop(); if ("function" != typeof n) throw new TypeError("The last argument must be of type Function"); function r() { return n.apply(i, arguments) } var i = this; a.apply(this, t).then(function (t) { o.nextTick(r, null, t) }, function (t) { o.nextTick(I, t, r) }) } return Object.setPrototypeOf(t, Object.getPrototypeOf(a)), Object.defineProperties(t, e(a)), t } }).call(this, x(0)) }, function (t, e, n) { "use strict"; t.exports = function (t, e, n, r) { for (var i = 65535 & t | 0, a = t >>> 16 & 65535 | 0, o = 0; 0 !== n;) { for (n -= o = 2e3 < n ? 2e3 : n; a = a + (i = i + e[r++] | 0) | 0, --o;); i %= 65521, a %= 65521 } return i | a << 16 | 0 } }, function (t, e, n) { "use strict"; var s = function () { for (var t, e = [], n = 0; n < 256; n++) { t = n; for (var r = 0; r < 8; r++)t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1; e[n] = t } return e }(); t.exports = function (t, e, n, r) { var i = s, a = r + n; t ^= -1; for (var o = r; o < a; o++)t = t >>> 8 ^ i[255 & (t ^ e[o])]; return -1 ^ t } }, function (t, e, r) { (function (F) { var M = r(27), n = r(39), B = r(6), U = r(40), j = r(51); e.readFile = function (t, e) { n.readFile(t, { encoding: "utf8" }, e) }, e.parseFile = ft, e.parse = i, e.Map = bt, e.TileSet = mt, e.Image = yt, e.Tile = vt, e.TileLayer = wt, e.ObjectLayer = Et, e.ImageLayer = Tt, e.TmxObject = St, e.Terrain = At; var z = 2147483648, Z = 1073741824, G = 536870912, H = 0, Y = H++, W = H++, q = H++, V = H++, X = H++, K = H++, Q = H++, J = H++, $ = H++, tt = H++, et = H++, nt = H++, rt = H++, it = H++, at = H++, ot = H++, st = H++, ut = H++, lt = H++, ct = H++; function i(t, e, n) { var s, r, a, i, o, u, l = B.dirname(e), c = M.parser(), f = null, h = Y, d = new Array(H), p = 0, g = 0, _ = null, b = 0, m = null, y = 0, v = null, w = 0, E = 0, T = null, S = 0, A = new j, k = []; function I(t) { return T.terrainTypes[parseInt(t, 10)] } function O(t) { a.horizontalFlips[E] = !!(t & z), a.verticalFlips[E] = !!(t & Z), a.diagonalFlips[E] = !!(t & G), t &= ~(z | Z | G), u.tiles[E] = t, E += 1 } function x(t) { var e = new yt; return e.format = t.attributes.FORMAT, e.source = t.attributes.SOURCE, e.trans = t.attributes.TRANS, e.width = pt(t.attributes.WIDTH), e.height = pt(t.attributes.HEIGHT), L(), e } function R(t, e) { (T = new mt).firstGid = pt(t.attributes.FIRSTGID), T.source = t.attributes.SOURCE, T.name = t.attributes.NAME, T.tileWidth = pt(t.attributes.TILEWIDTH), T.tileHeight = pt(t.attributes.TILEHEIGHT), T.spacing = pt(t.attributes.SPACING), T.margin = pt(t.attributes.MARGIN), T.source && A.go(function (t) { !function (n, r) { ft(B.join(l, n.source), function (t, e) { t ? r(t) : (e.mergeTo(n), r()) }) }(T, t) }), h = Q, S = e } function N(t) { _ = t, b = h, h = q } function L() { p = h, h = K, g = 1 } function D(t) { c.onerror = null, c.onopentag = null, c.onclosetag = null, c.ontext = null, c.onend = null, n(t) } function P(t) { for (var e = 0; e < t.tiles.length; e += 1)for (var n = t.tiles[e], r = s.tileSets.length - 1; 0 <= r; r -= 1) { var i = s.tileSets[r]; if (i.firstGid <= n) { var a = n - i.firstGid, o = i.tiles[a]; o || ((o = new vt).id = a, i.tiles[a] = o), o.gid = n, t.layer.tiles[e] = o; break } } } function C(t) { var e = s.width * s.height * 4; if (t.length === e) for (var n = E = 0; n < e; n += 4)O(t.readUInt32LE(n)); else D(new Error("Expected " + e + " bytes of tile data; received " + t.length)) } d[Y] = { opentag: function (t) { "MAP" === t.name ? (s = new bt, (f = s).version = t.attributes.VERSION, s.orientation = t.attributes.ORIENTATION, s.width = pt(t.attributes.WIDTH), s.height = pt(t.attributes.HEIGHT), s.tileWidth = pt(t.attributes.TILEWIDTH), s.tileHeight = pt(t.attributes.TILEHEIGHT), s.backgroundColor = t.attributes.BACKGROUNDCOLOR, h = W) : "TILESET" === t.name ? (R(t, Y), f = T) : L() }, closetag: dt, text: dt }, d[W] = { opentag: function (t) { switch (t.name) { case "PROPERTIES": N(s.properties); break; case "TILESET": R(t, W), s.tileSets.push(T); break; case "LAYER": a = new wt(s), E = 0, a.name = t.attributes.NAME, a.opacity = _t(t.attributes.OPACITY, 1), a.visible = gt(t.attributes.VISIBLE, !0), s.layers.push(a), u = { layer: a, tiles: new Array(s.width * s.height) }, k.push(u), h = $; break; case "OBJECTGROUP": (a = new Et).name = t.attributes.NAME, a.color = t.attributes.COLOR, a.opacity = _t(t.attributes.OPACITY, 1), a.visible = gt(t.attributes.VISIBLE, !0), s.layers.push(a), h = tt; break; case "IMAGELAYER": (a = new Tt).name = t.attributes.NAME, a.x = pt(t.attributes.X), a.y = pt(t.attributes.Y), a.opacity = _t(t.attributes.OPACITY, 1), a.visible = gt(t.attributes.VISIBLE, !0), s.layers.push(a), h = rt; break; default: L() } }, closetag: dt, text: dt }, d[Q] = { opentag: function (t) { switch (t.name) { case "TILEOFFSET": T.tileOffset.x = pt(t.attributes.X), T.tileOffset.y = pt(t.attributes.Y), L(); break; case "PROPERTIES": N(T.properties); break; case "IMAGE": T.image = x(t); break; case "TERRAINTYPES": h = lt; break; case "TILE": if ((r = new vt).id = pt(t.attributes.ID), t.attributes.TERRAIN) { var e = t.attributes.TERRAIN.split(","); r.terrain = e.map(I) } r.probability = _t(t.attributes.PROBABILITY), T.tiles[r.id] = r, h = J; break; default: L() } }, closetag: function (t) { h = S }, text: dt }, d[q] = { opentag: function (t) { "PROPERTY" === t.name && (_[t.attributes.NAME] = function (t, e) { switch (e) { case "int": return parseInt(t, 10); case "float": return parseFloat(t, 2); case "bool": return "true" === t; default: return t } }(t.attributes.VALUE, t.attributes.TYPE)), L() }, closetag: function (t) { h = b }, text: dt }, d[V] = { opentag: function (t) { "FRAME" === t.name && m.push({ tileId: t.attributes.TILEID, duration: t.attributes.DURATION }), L() }, closetag: function (t) { h = y }, text: dt }, d[X] = { opentag: function (t) { "OBJECT" === t.name ? ((i = new St).name = t.attributes.NAME, i.type = t.attributes.TYPE, i.x = pt(t.attributes.X), i.y = pt(t.attributes.Y), i.width = pt(t.attributes.WIDTH, 0), i.height = pt(t.attributes.HEIGHT, 0), i.rotation = _t(t.attributes.ROTATION, 0), i.gid = pt(t.attributes.GID), i.visible = gt(t.attributes.VISIBLE, !0), v.push(i), h = nt) : L() }, closetag: function (t) { h = w }, text: dt }, d[K] = { opentag: function (t) { g += 1 }, closetag: function (t) { 0 === (g -= 1) && (h = p) }, text: dt }, d[J] = { opentag: function (t) { "PROPERTIES" === t.name ? N(r.properties) : "IMAGE" === t.name ? r.image = x(t) : "ANIMATION" === t.name ? r.animation = function (t) { m = t, y = h, h = V }(r.animations) : "OBJECTGROUP" === t.name ? r.objectGroup = function (t) { v = t, w = h, h = X }(r.objectGroups) : L() }, closetag: function (t) { h = Q }, text: dt }, d[$] = { opentag: function (t) { if ("PROPERTIES" === t.name) N(a.properties); else if ("DATA" === t.name) { var e = t.attributes.ENCODING, n = t.attributes.COMPRESSION; switch (e) { case void 0: case null: h = it; break; case "csv": h = at; break; case "base64": switch (n) { case void 0: case null: h = ot; break; case "gzip": h = st; break; case "zlib": h = ut; break; default: return void D(new Error("unsupported data compression: " + n)) }break; default: return void D(new Error("unsupported data encoding: " + e)) } } else L() }, closetag: function (t) { h = W }, text: dt }, d[tt] = { opentag: function (t) { "PROPERTIES" === t.name ? N(a.properties) : "OBJECT" === t.name ? ((i = new St).name = t.attributes.NAME, i.type = t.attributes.TYPE, i.x = pt(t.attributes.X), i.y = pt(t.attributes.Y), i.width = pt(t.attributes.WIDTH, 0), i.height = pt(t.attributes.HEIGHT, 0), i.rotation = _t(t.attributes.ROTATION, 0), i.gid = pt(t.attributes.GID), i.visible = gt(t.attributes.VISIBLE, !0), a.objects.push(i), h = et) : L() }, closetag: function (t) { h = W }, text: dt }, d[rt] = { opentag: function (t) { "PROPERTIES" === t.name ? N(a.properties) : "IMAGE" === t.name ? a.image = x(t) : L() }, closetag: function (t) { h = W }, text: dt }, d[et] = { opentag: function (t) { switch (t.name) { case "PROPERTIES": N(i.properties); break; case "ELLIPSE": i.ellipse = !0, L(); break; case "POLYGON": i.polygon = ht(t.attributes.POINTS), L(); break; case "POLYLINE": i.polyline = ht(t.attributes.POINTS), L(); break; case "IMAGE": i.image = x(t); break; default: L() } }, closetag: function (t) { h = tt }, text: dt }, d[nt] = { opentag: function (t) { switch (t.name) { case "PROPERTIES": N(i.properties); break; case "ELLIPSE": i.ellipse = !0, L(); break; case "POLYGON": i.polygon = ht(t.attributes.POINTS), L(); break; case "POLYLINE": i.polyline = ht(t.attributes.POINTS), L(); break; case "IMAGE": i.image = x(t); break; default: L() } }, closetag: function (t) { h = X }, text: dt }, d[it] = { opentag: function (t) { "TILE" === t.name && O(pt(t.attributes.GID, 0)), L() }, closetag: function (t) { h = $ }, text: dt }, d[at] = { opentag: function (t) { L() }, closetag: function (t) { h = $ }, text: function (t) { t.split(",").forEach(function (t) { O(parseInt(t, 10)) }) } }, d[ot] = { opentag: function (t) { L() }, closetag: function (t) { h = $ }, text: function (t) { C(new F(t.trim(), "base64")) } }, d[st] = { opentag: function (t) { L() }, closetag: function (t) { h = $ }, text: function (t) { var e = new F(t.trim(), "base64"), r = u, i = a; A.go(function (n) { U.gunzip(e, function (t, e) { t ? n(t) : (u = r, a = i, C(e), n()) }) }) } }, d[ut] = { opentag: function (t) { L() }, closetag: function (t) { h = $ }, text: function (t) { var e = new F(t.trim(), "base64"), r = u, i = a; A.go(function (n) { U.inflate(e, function (t, e) { t ? n(t) : (a = i, u = r, C(e), n()) }) }) } }, d[lt] = { opentag: function (t) { "TERRAIN" === t.name ? ((o = new At).name = t.attributes.NAME, o.tile = pt(t.attributes.TILE), T.terrainTypes.push(o), h = ct) : L() }, closetag: function (t) { h = Q }, text: dt }, d[ct] = { opentag: function (t) { "PROPERTIES" === t.name ? N(o.properties) : L() }, closetag: function (t) { h = lt }, text: dt }, c.onerror = n, c.onopentag = function (t) { d[h].opentag(t) }, c.onclosetag = function (t) { d[h].closetag(t) }, c.ontext = function (t) { d[h].text(t) }, c.onend = function () { A.wait(function (t) { t ? n(t) : (k.forEach(P), n(null, f)) }) }, c.write(t).close() } function ft(n, r) { e.readFile(n, function (t, e) { t ? r(t) : i(e, n, r) }) } function ht(t) { return t.split(" ").map(function (t) { var e = t.split(","); return { x: e[0], y: e[1] } }) } function dt() { } function pt(t, e) { return e = null == e ? null : e, null == t ? e : parseInt(t, 10) } function gt(t, e) { return e = null == e ? null : e, null == t ? e : !!parseInt(t, 10) } function _t(t, e) { return e = null == e ? null : e, null == t ? e : parseFloat(t, 10) } function bt() { this.version = null, this.orientation = "orthogonal", this.width = 0, this.height = 0, this.tileWidth = 0, this.tileHeight = 0, this.backgroundColor = null, this.layers = [], this.properties = {}, this.tileSets = [] } function mt() { this.firstGid = 0, this.source = "", this.name = "", this.tileWidth = 0, this.tileHeight = 0, this.spacing = 0, this.margin = 0, this.tileOffset = { x: 0, y: 0 }, this.properties = {}, this.image = null, this.tiles = [], this.terrainTypes = [] } function yt() { this.format = null, this.source = "", this.trans = null, this.width = 0, this.height = 0 } function vt() { this.id = 0, this.terrain = [], this.probability = null, this.properties = {}, this.animations = [], this.objectGroups = [], this.image = null } function wt(t) { var e = t.width * t.height; this.map = t, this.type = "tile", this.name = null, this.opacity = 1, this.visible = !0, this.properties = {}, this.tiles = new Array(e), this.horizontalFlips = new Array(e), this.verticalFlips = new Array(e), this.diagonalFlips = new Array(e) } function Et() { this.type = "object", this.name = null, this.color = null, this.opacity = 1, this.visible = !0, this.properties = {}, this.objects = [] } function Tt() { this.type = "image", this.name = null, this.x = 0, this.y = 0, this.opacity = 1, this.visible = !0, this.properties = {}, this.image = null } function St() { this.name = null, this.type = null, this.x = 0, this.y = 0, this.width = 0, this.height = 0, this.rotation = 0, this.properties = {}, this.gid = null, this.visible = !0, this.ellipse = !1, this.polygon = null, this.polyline = null } function At() { this.name = "", this.tile = 0, this.properties = {} } mt.prototype.mergeTo = function (t) { t.firstGid = null == this.firstGid ? t.firstGid : this.firstGid, t.source = null == this.source ? t.source : this.source, t.name = null == this.name ? t.name : this.name, t.tileWidth = null == this.tileWidth ? t.tileWidth : this.tileWidth, t.tileHeight = null == this.tileHeight ? t.tileHeight : this.tileHeight, t.spacing = null == this.spacing ? t.spacing : this.spacing, t.margin = null == this.margin ? t.margin : this.margin, t.tileOffset = null == this.tileOffset ? t.tileOffset : this.tileOffset, t.properties = null == this.properties ? t.properties : this.properties, t.image = null == this.image ? t.image : this.image, t.tiles = null == this.tiles ? t.tiles : this.tiles, t.terrainTypes = null == this.terrainTypes ? t.terrainTypes : this.terrainTypes }, wt.prototype.tileAt = function (t, e) { return this.tiles[e * this.map.width + t] }, wt.prototype.setTileAt = function (t, e, n) { this.tiles[e * this.map.width + t] = n } }).call(this, r(1).Buffer) }, function (t, e, n) { "use strict"; e.byteLength = function (t) { var e = f(t), n = e[0], r = e[1]; return 3 * (n + r) / 4 - r }, e.toByteArray = function (t) { for (var e, n = f(t), r = n[0], i = n[1], a = new c(function (t, e, n) { return 3 * (e + n) / 4 - n }(0, r, i)), o = 0, s = 0 < i ? r - 4 : r, u = 0; u < s; u += 4)e = l[t.charCodeAt(u)] << 18 | l[t.charCodeAt(u + 1)] << 12 | l[t.charCodeAt(u + 2)] << 6 | l[t.charCodeAt(u + 3)], a[o++] = e >> 16 & 255, a[o++] = e >> 8 & 255, a[o++] = 255 & e; 2 === i && (e = l[t.charCodeAt(u)] << 2 | l[t.charCodeAt(u + 1)] >> 4, a[o++] = 255 & e); 1 === i && (e = l[t.charCodeAt(u)] << 10 | l[t.charCodeAt(u + 1)] << 4 | l[t.charCodeAt(u + 2)] >> 2, a[o++] = e >> 8 & 255, a[o++] = 255 & e); return a }, e.fromByteArray = function (t) { for (var e, n = t.length, r = n % 3, i = [], a = 0, o = n - r; a < o; a += 16383)i.push(u(t, a, o < a + 16383 ? o : a + 16383)); 1 == r ? (e = t[n - 1], i.push(s[e >> 2] + s[e << 4 & 63] + "==")) : 2 == r && (e = (t[n - 2] << 8) + t[n - 1], i.push(s[e >> 10] + s[e >> 4 & 63] + s[e << 2 & 63] + "=")); return i.join("") }; for (var s = [], l = [], c = "undefined" != typeof Uint8Array ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, a = r.length; i < a; ++i)s[i] = r[i], l[r.charCodeAt(i)] = i; function f(t) { var e = t.length; if (0 < e % 4) throw new Error("Invalid string. Length must be a multiple of 4"); var n = t.indexOf("="); return -1 === n && (n = e), [n, n === e ? 0 : 4 - n % 4] } function u(t, e, n) { for (var r, i, a = [], o = e; o < n; o += 3)r = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (255 & t[o + 2]), a.push(s[(i = r) >> 18 & 63] + s[i >> 12 & 63] + s[i >> 6 & 63] + s[63 & i]); return a.join("") } l["-".charCodeAt(0)] = 62, l["_".charCodeAt(0)] = 63 }, function (t, e) { e.read = function (t, e, n, r, i) { var a, o, s = 8 * i - r - 1, u = (1 << s) - 1, l = u >> 1, c = -7, f = n ? i - 1 : 0, h = n ? -1 : 1, d = t[e + f]; for (f += h, a = d & (1 << -c) - 1, d >>= -c, c += s; 0 < c; a = 256 * a + t[e + f], f += h, c -= 8); for (o = a & (1 << -c) - 1, a >>= -c, c += r; 0 < c; o = 256 * o + t[e + f], f += h, c -= 8); if (0 === a) a = 1 - l; else { if (a === u) return o ? NaN : 1 / 0 * (d ? -1 : 1); o += Math.pow(2, r), a -= l } return (d ? -1 : 1) * o * Math.pow(2, a - r) }, e.write = function (t, e, n, r, i, a) { var o, s, u, l = 8 * a - i - 1, c = (1 << l) - 1, f = c >> 1, h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : a - 1, p = r ? 1 : -1, g = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, o = c) : (o = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -o)) < 1 && (o-- , u *= 2), 2 <= (e += 1 <= o + f ? h / u : h * Math.pow(2, 1 - f)) * u && (o++ , u /= 2), c <= o + f ? (s = 0, o = c) : 1 <= o + f ? (s = (e * u - 1) * Math.pow(2, i), o += f) : (s = e * Math.pow(2, f - 1) * Math.pow(2, i), o = 0)); 8 <= i; t[n + d] = 255 & s, d += p, s /= 256, i -= 8); for (o = o << i | s, l += i; 0 < l; t[n + d] = 255 & o, d += p, o /= 256, l -= 8); t[n + d - p] |= 128 * g } }, function (t, e, H) {
    (function (G) {
      !function (u) {
      u.parser = function (t, e) { return new i(t, e) }, u.SAXParser = i, u.SAXStream = o, u.createStream = function (t, e) { return new o(t, e) }, u.MAX_BUFFER_LENGTH = 65536; var r, l = ["comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script"]; function i(t, e) { if (!(this instanceof i)) return new i(t, e); var n = this; !function (t) { for (var e = 0, n = l.length; e < n; e++)t[l[e]] = "" }(n), n.q = n.c = "", n.bufferCheckPosition = u.MAX_BUFFER_LENGTH, n.opt = e || {}, n.opt.lowercase = n.opt.lowercase || n.opt.lowercasetags, n.looseCase = n.opt.lowercase ? "toLowerCase" : "toUpperCase", n.tags = [], n.closed = n.closedRoot = n.sawRoot = !1, n.tag = n.error = null, n.strict = !!t, n.noscript = !(!t && !n.opt.noscript), n.state = A.BEGIN, n.strictEntities = n.opt.strictEntities, n.ENTITIES = n.strictEntities ? Object.create(u.XML_ENTITIES) : Object.create(u.ENTITIES), n.attribList = [], n.opt.xmlns && (n.ns = Object.create(_)), n.trackPosition = !1 !== n.opt.position, n.trackPosition && (n.position = n.line = n.column = 0), I(n, "onready") } u.EVENTS = ["text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace"], Object.create || (Object.create = function (t) { function e() { } return e.prototype = t, new e }), Object.keys || (Object.keys = function (t) { var e = []; for (var n in t) t.hasOwnProperty(n) && e.push(n); return e }), i.prototype = {
        end: function () { L(this) }, write: function (t) { var e = this; if (this.error) throw this.error; if (e.closed) return N(e, "Cannot write after close. Assign an onready handler."); if (null === t) return L(e); "object" == typeof t && (t = t.toString()); var n = 0, r = ""; for (; r = z(t, n++), e.c = r;)switch (e.trackPosition && (e.position++ , "\n" === r ? (e.line++ , e.column = 0) : e.column++), e.state) { case A.BEGIN: if (e.state = A.BEGIN_WHITESPACE, "\ufeff" === r) continue; j(e, r); continue; case A.BEGIN_WHITESPACE: j(e, r); continue; case A.TEXT: if (e.sawRoot && !e.closedRoot) { for (var i = n - 1; r && "<" !== r && "&" !== r;)(r = z(t, n++)) && e.trackPosition && (e.position++ , "\n" === r ? (e.line++ , e.column = 0) : e.column++); e.textNode += t.substring(i, n - 1) } "<" !== r || e.sawRoot && e.closedRoot && !e.strict ? (!E(c, r) || e.sawRoot && !e.closedRoot || D(e, "Text data outside of root node."), "&" === r ? e.state = A.TEXT_ENTITY : e.textNode += r) : (e.state = A.OPEN_WAKA, e.startTagPosition = e.position); continue; case A.SCRIPT: "<" === r ? e.state = A.SCRIPT_ENDING : e.script += r; continue; case A.SCRIPT_ENDING: "/" === r ? e.state = A.CLOSE_TAG : (e.script += "<" + r, e.state = A.SCRIPT); continue; case A.OPEN_WAKA: if ("!" === r) e.state = A.SGML_DECL, e.sgmlDecl = ""; else if (w(c, r)); else if (w(b, r)) e.state = A.OPEN_TAG, e.tagName = r; else if ("/" === r) e.state = A.CLOSE_TAG, e.tagName = ""; else if ("?" === r) e.state = A.PROC_INST, e.procInstName = e.procInstBody = ""; else { if (D(e, "Unencoded <"), e.startTagPosition + 1 < e.position) { var a = e.position - e.startTagPosition; r = new Array(a).join(" ") + r } e.textNode += "<" + r, e.state = A.TEXT } continue; case A.SGML_DECL: (e.sgmlDecl + r).toUpperCase() === d ? (O(e, "onopencdata"), e.state = A.CDATA, e.sgmlDecl = "", e.cdata = "") : e.sgmlDecl + r === "--" ? (e.state = A.COMMENT, e.comment = "", e.sgmlDecl = "") : (e.sgmlDecl + r).toUpperCase() === p ? (e.state = A.DOCTYPE, (e.doctype || e.sawRoot) && D(e, "Inappropriately located doctype declaration"), e.doctype = "", e.sgmlDecl = "") : ">" === r ? (O(e, "onsgmldeclaration", e.sgmlDecl), e.sgmlDecl = "", e.state = A.TEXT) : (w(f, r) && (e.state = A.SGML_DECL_QUOTED), e.sgmlDecl += r); continue; case A.SGML_DECL_QUOTED: r === e.q && (e.state = A.SGML_DECL, e.q = ""), e.sgmlDecl += r; continue; case A.DOCTYPE: ">" === r ? (e.state = A.TEXT, O(e, "ondoctype", e.doctype), e.doctype = !0) : (e.doctype += r, "[" === r ? e.state = A.DOCTYPE_DTD : w(f, r) && (e.state = A.DOCTYPE_QUOTED, e.q = r)); continue; case A.DOCTYPE_QUOTED: e.doctype += r, r === e.q && (e.q = "", e.state = A.DOCTYPE); continue; case A.DOCTYPE_DTD: e.doctype += r, "]" === r ? e.state = A.DOCTYPE : w(f, r) && (e.state = A.DOCTYPE_DTD_QUOTED, e.q = r); continue; case A.DOCTYPE_DTD_QUOTED: e.doctype += r, r === e.q && (e.state = A.DOCTYPE_DTD, e.q = ""); continue; case A.COMMENT: "-" === r ? e.state = A.COMMENT_ENDING : e.comment += r; continue; case A.COMMENT_ENDING: "-" === r ? (e.state = A.COMMENT_ENDED, e.comment = R(e.opt, e.comment), e.comment && O(e, "oncomment", e.comment), e.comment = "") : (e.comment += "-" + r, e.state = A.COMMENT); continue; case A.COMMENT_ENDED: ">" !== r ? (D(e, "Malformed comment"), e.comment += "--" + r, e.state = A.COMMENT) : e.state = A.TEXT; continue; case A.CDATA: "]" === r ? e.state = A.CDATA_ENDING : e.cdata += r; continue; case A.CDATA_ENDING: "]" === r ? e.state = A.CDATA_ENDING_2 : (e.cdata += "]" + r, e.state = A.CDATA); continue; case A.CDATA_ENDING_2: ">" === r ? (e.cdata && O(e, "oncdata", e.cdata), O(e, "onclosecdata"), e.cdata = "", e.state = A.TEXT) : "]" === r ? e.cdata += "]" : (e.cdata += "]]" + r, e.state = A.CDATA); continue; case A.PROC_INST: "?" === r ? e.state = A.PROC_INST_ENDING : w(c, r) ? e.state = A.PROC_INST_BODY : e.procInstName += r; continue; case A.PROC_INST_BODY: if (!e.procInstBody && w(c, r)) continue; "?" === r ? e.state = A.PROC_INST_ENDING : e.procInstBody += r; continue; case A.PROC_INST_ENDING: ">" === r ? (O(e, "onprocessinginstruction", { name: e.procInstName, body: e.procInstBody }), e.procInstName = e.procInstBody = "", e.state = A.TEXT) : (e.procInstBody += "?" + r, e.state = A.PROC_INST_BODY); continue; case A.OPEN_TAG: w(m, r) ? e.tagName += r : (P(e), ">" === r ? M(e) : "/" === r ? e.state = A.OPEN_TAG_SLASH : (E(c, r) && D(e, "Invalid character in tag name"), e.state = A.ATTRIB)); continue; case A.OPEN_TAG_SLASH: ">" === r ? (M(e, !0), B(e)) : (D(e, "Forward-slash in opening tag not followed by >"), e.state = A.ATTRIB); continue; case A.ATTRIB: if (w(c, r)) continue; ">" === r ? M(e) : "/" === r ? e.state = A.OPEN_TAG_SLASH : w(b, r) ? (e.attribName = r, e.attribValue = "", e.state = A.ATTRIB_NAME) : D(e, "Invalid attribute name"); continue; case A.ATTRIB_NAME: "=" === r ? e.state = A.ATTRIB_VALUE : ">" === r ? (D(e, "Attribute without value"), e.attribValue = e.attribName, F(e), M(e)) : w(c, r) ? e.state = A.ATTRIB_NAME_SAW_WHITE : w(m, r) ? e.attribName += r : D(e, "Invalid attribute name"); continue; case A.ATTRIB_NAME_SAW_WHITE: if ("=" === r) e.state = A.ATTRIB_VALUE; else { if (w(c, r)) continue; D(e, "Attribute without value"), e.tag.attributes[e.attribName] = "", e.attribValue = "", O(e, "onattribute", { name: e.attribName, value: "" }), e.attribName = "", ">" === r ? M(e) : w(b, r) ? (e.attribName = r, e.state = A.ATTRIB_NAME) : (D(e, "Invalid attribute name"), e.state = A.ATTRIB) } continue; case A.ATTRIB_VALUE: if (w(c, r)) continue; w(f, r) ? (e.q = r, e.state = A.ATTRIB_VALUE_QUOTED) : (D(e, "Unquoted attribute value"), e.state = A.ATTRIB_VALUE_UNQUOTED, e.attribValue = r); continue; case A.ATTRIB_VALUE_QUOTED: if (r !== e.q) { "&" === r ? e.state = A.ATTRIB_VALUE_ENTITY_Q : e.attribValue += r; continue } F(e), e.q = "", e.state = A.ATTRIB_VALUE_CLOSED; continue; case A.ATTRIB_VALUE_CLOSED: w(c, r) ? e.state = A.ATTRIB : ">" === r ? M(e) : "/" === r ? e.state = A.OPEN_TAG_SLASH : w(b, r) ? (D(e, "No whitespace between attributes"), e.attribName = r, e.attribValue = "", e.state = A.ATTRIB_NAME) : D(e, "Invalid attribute name"); continue; case A.ATTRIB_VALUE_UNQUOTED: if (E(h, r)) { "&" === r ? e.state = A.ATTRIB_VALUE_ENTITY_U : e.attribValue += r; continue } F(e), ">" === r ? M(e) : e.state = A.ATTRIB; continue; case A.CLOSE_TAG: if (e.tagName) ">" === r ? B(e) : w(m, r) ? e.tagName += r : e.script ? (e.script += "</" + e.tagName, e.tagName = "", e.state = A.SCRIPT) : (E(c, r) && D(e, "Invalid tagname in closing tag"), e.state = A.CLOSE_TAG_SAW_WHITE); else { if (w(c, r)) continue; E(b, r) ? e.script ? (e.script += "</" + r, e.state = A.SCRIPT) : D(e, "Invalid tagname in closing tag.") : e.tagName = r } continue; case A.CLOSE_TAG_SAW_WHITE: if (w(c, r)) continue; ">" === r ? B(e) : D(e, "Invalid characters in closing tag"); continue; case A.TEXT_ENTITY: case A.ATTRIB_VALUE_ENTITY_Q: case A.ATTRIB_VALUE_ENTITY_U: var o, s; switch (e.state) { case A.TEXT_ENTITY: o = A.TEXT, s = "textNode"; break; case A.ATTRIB_VALUE_ENTITY_Q: o = A.ATTRIB_VALUE_QUOTED, s = "attribValue"; break; case A.ATTRIB_VALUE_ENTITY_U: o = A.ATTRIB_VALUE_UNQUOTED, s = "attribValue" }";" === r ? (e[s] += U(e), e.entity = "", e.state = o) : w(e.entity.length ? v : y, r) ? e.entity += r : (D(e, "Invalid character in entity name"), e[s] += "&" + e.entity + r, e.entity = "", e.state = o); continue; default: throw new Error(e, "Unknown state: " + e.state) }e.position >= e.bufferCheckPosition && function (t) { for (var e = Math.max(u.MAX_BUFFER_LENGTH, 10), n = 0, r = 0, i = l.length; r < i; r++) { var a = t[l[r]].length; if (e < a) switch (l[r]) { case "textNode": x(t); break; case "cdata": O(t, "oncdata", t.cdata), t.cdata = ""; break; case "script": O(t, "onscript", t.script), t.script = ""; break; default: N(t, "Max buffer length exceeded: " + l[r]) }n = Math.max(n, a) } var o = u.MAX_BUFFER_LENGTH - n; t.bufferCheckPosition = o + t.position }(e); return e }
/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */, resume: function () { return this.error = null, this }, close: function () { return this.write(null) }, flush: function () { !function (t) { x(t), "" !== t.cdata && (O(t, "oncdata", t.cdata), t.cdata = ""), "" !== t.script && (O(t, "onscript", t.script), t.script = "") }(this) }
      }; try { r = H(15).Stream } catch (t) { r = function () { } } var a = u.EVENTS.filter(function (t) { return "error" !== t && "end" !== t }); function o(t, e) { if (!(this instanceof o)) return new o(t, e); r.apply(this), this._parser = new i(t, e), this.writable = !0, this.readable = !0; var n = this; this._parser.onend = function () { n.emit("end") }, this._parser.onerror = function (t) { n.emit("error", t), n._parser.error = null }, this._decoder = null, a.forEach(function (e) { Object.defineProperty(n, "on" + e, { get: function () { return n._parser["on" + e] }, set: function (t) { if (!t) return n.removeAllListeners(e), n._parser["on" + e] = t; n.on(e, t) }, enumerable: !0, configurable: !1 }) }) } (o.prototype = Object.create(r.prototype, { constructor: { value: o } })).write = function (t) { if ("function" == typeof G && "function" == typeof G.isBuffer && G.isBuffer(t)) { if (!this._decoder) { var e = H(13).StringDecoder; this._decoder = new e("utf8") } t = this._decoder.write(t) } return this._parser.write(t.toString()), this.emit("data", t), !0 }, o.prototype.end = function (t) { return t && t.length && this.write(t), this._parser.end(), !0 }, o.prototype.on = function (e, t) { var n = this; return n._parser["on" + e] || -1 === a.indexOf(e) || (n._parser["on" + e] = function () { var t = 1 === arguments.length ? [arguments[0]] : Array.apply(null, arguments); t.splice(0, 0, e), n.emit.apply(n, t) }), r.prototype.on.call(n, e, t) }; var c = "\r\n\t ", t = "0124356789", e = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", f = "'\"", h = c + ">", d = "[CDATA[", p = "DOCTYPE", s = "http://www.w3.org/XML/1998/namespace", g = "http://www.w3.org/2000/xmlns/", _ = { xml: s, xmlns: g }; c = n(c), t = n(t), e = n(e); var b = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, m = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/, y = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, v = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/; function n(t) { return t.split("").reduce(function (t, e) { return t[e] = !0, t }, {}) } function w(t, e) { return function (t) { return "[object RegExp]" === Object.prototype.toString.call(t) }(t) ? !!e.match(t) : t[e] } function E(t, e) { return !w(t, e) } f = n(f), h = n(h); var T, S, A = 0; for (var k in u.STATE = { BEGIN: A++, BEGIN_WHITESPACE: A++, TEXT: A++, TEXT_ENTITY: A++, OPEN_WAKA: A++, SGML_DECL: A++, SGML_DECL_QUOTED: A++, DOCTYPE: A++, DOCTYPE_QUOTED: A++, DOCTYPE_DTD: A++, DOCTYPE_DTD_QUOTED: A++, COMMENT_STARTING: A++, COMMENT: A++, COMMENT_ENDING: A++, COMMENT_ENDED: A++, CDATA: A++, CDATA_ENDING: A++, CDATA_ENDING_2: A++, PROC_INST: A++, PROC_INST_BODY: A++, PROC_INST_ENDING: A++, OPEN_TAG: A++, OPEN_TAG_SLASH: A++, ATTRIB: A++, ATTRIB_NAME: A++, ATTRIB_NAME_SAW_WHITE: A++, ATTRIB_VALUE: A++, ATTRIB_VALUE_QUOTED: A++, ATTRIB_VALUE_CLOSED: A++, ATTRIB_VALUE_UNQUOTED: A++, ATTRIB_VALUE_ENTITY_Q: A++, ATTRIB_VALUE_ENTITY_U: A++, CLOSE_TAG: A++, CLOSE_TAG_SAW_WHITE: A++, SCRIPT: A++, SCRIPT_ENDING: A++ }, u.XML_ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'" }, u.ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'", AElig: 198, Aacute: 193, Acirc: 194, Agrave: 192, Aring: 197, Atilde: 195, Auml: 196, Ccedil: 199, ETH: 208, Eacute: 201, Ecirc: 202, Egrave: 200, Euml: 203, Iacute: 205, Icirc: 206, Igrave: 204, Iuml: 207, Ntilde: 209, Oacute: 211, Ocirc: 212, Ograve: 210, Oslash: 216, Otilde: 213, Ouml: 214, THORN: 222, Uacute: 218, Ucirc: 219, Ugrave: 217, Uuml: 220, Yacute: 221, aacute: 225, acirc: 226, aelig: 230, agrave: 224, aring: 229, atilde: 227, auml: 228, ccedil: 231, eacute: 233, ecirc: 234, egrave: 232, eth: 240, euml: 235, iacute: 237, icirc: 238, igrave: 236, iuml: 239, ntilde: 241, oacute: 243, ocirc: 244, ograve: 242, oslash: 248, otilde: 245, ouml: 246, szlig: 223, thorn: 254, uacute: 250, ucirc: 251, ugrave: 249, uuml: 252, yacute: 253, yuml: 255, copy: 169, reg: 174, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, ordf: 170, laquo: 171, not: 172, shy: 173, macr: 175, deg: 176, plusmn: 177, sup1: 185, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, times: 215, divide: 247, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 }, Object.keys(u.ENTITIES).forEach(function (t) { var e = u.ENTITIES[t], n = "number" == typeof e ? String.fromCharCode(e) : e; u.ENTITIES[t] = n }), u.STATE) u.STATE[u.STATE[k]] = k; function I(t, e, n) { t[e] && t[e](n) } function O(t, e, n) { t.textNode && x(t), I(t, e, n) } function x(t) { t.textNode = R(t.opt, t.textNode), t.textNode && I(t, "ontext", t.textNode), t.textNode = "" } function R(t, e) { return t.trim && (e = e.trim()), t.normalize && (e = e.replace(/\s+/g, " ")), e } function N(t, e) { return x(t), t.trackPosition && (e += "\nLine: " + t.line + "\nColumn: " + t.column + "\nChar: " + t.c), e = new Error(e), t.error = e, I(t, "onerror", e), t } function L(t) { return t.sawRoot && !t.closedRoot && D(t, "Unclosed root tag"), t.state !== A.BEGIN && t.state !== A.BEGIN_WHITESPACE && t.state !== A.TEXT && N(t, "Unexpected end"), x(t), t.c = "", t.closed = !0, I(t, "onend"), i.call(t, t.strict, t.opt), t } function D(t, e) { if ("object" != typeof t || !(t instanceof i)) throw new Error("bad call to strictFail"); t.strict && N(t, e) } function P(t) { t.strict || (t.tagName = t.tagName[t.looseCase]()); var e = t.tags[t.tags.length - 1] || t, n = t.tag = { name: t.tagName, attributes: {} }; t.opt.xmlns && (n.ns = e.ns), t.attribList.length = 0 } function C(t, e) { var n = t.indexOf(":") < 0 ? ["", t] : t.split(":"), r = n[0], i = n[1]; return e && "xmlns" === t && (r = "xmlns", i = ""), { prefix: r, local: i } } function F(t) { if (t.strict || (t.attribName = t.attribName[t.looseCase]()), -1 !== t.attribList.indexOf(t.attribName) || t.tag.attributes.hasOwnProperty(t.attribName)) t.attribName = t.attribValue = ""; else { if (t.opt.xmlns) { var e = C(t.attribName, !0), n = e.prefix, r = e.local; if ("xmlns" === n) if ("xml" === r && t.attribValue !== s) D(t, "xml: prefix must be bound to " + s + "\nActual: " + t.attribValue); else if ("xmlns" === r && t.attribValue !== g) D(t, "xmlns: prefix must be bound to " + g + "\nActual: " + t.attribValue); else { var i = t.tag, a = t.tags[t.tags.length - 1] || t; i.ns === a.ns && (i.ns = Object.create(a.ns)), i.ns[r] = t.attribValue } t.attribList.push([t.attribName, t.attribValue]) } else t.tag.attributes[t.attribName] = t.attribValue, O(t, "onattribute", { name: t.attribName, value: t.attribValue }); t.attribName = t.attribValue = "" } } function M(e, t) { if (e.opt.xmlns) { var n = e.tag, r = C(e.tagName); n.prefix = r.prefix, n.local = r.local, n.uri = n.ns[r.prefix] || "", n.prefix && !n.uri && (D(e, "Unbound namespace prefix: " + JSON.stringify(e.tagName)), n.uri = r.prefix); var i = e.tags[e.tags.length - 1] || e; n.ns && i.ns !== n.ns && Object.keys(n.ns).forEach(function (t) { O(e, "onopennamespace", { prefix: t, uri: n.ns[t] }) }); for (var a = 0, o = e.attribList.length; a < o; a++) { var s = e.attribList[a], u = s[0], l = s[1], c = C(u, !0), f = c.prefix, h = c.local, d = "" === f ? "" : n.ns[f] || "", p = { name: u, value: l, prefix: f, local: h, uri: d }; f && "xmlns" !== f && !d && (D(e, "Unbound namespace prefix: " + JSON.stringify(f)), p.uri = f), e.tag.attributes[u] = p, O(e, "onattribute", p) } e.attribList.length = 0 } e.tag.isSelfClosing = !!t, e.sawRoot = !0, e.tags.push(e.tag), O(e, "onopentag", e.tag), t || (e.noscript || "script" !== e.tagName.toLowerCase() ? e.state = A.TEXT : e.state = A.SCRIPT, e.tag = null, e.tagName = ""), e.attribName = e.attribValue = "", e.attribList.length = 0 } function B(n) { if (!n.tagName) return D(n, "Weird empty close tag."), n.textNode += "</>", void (n.state = A.TEXT); if (n.script) { if ("script" !== n.tagName) return n.script += "</" + n.tagName + ">", n.tagName = "", void (n.state = A.SCRIPT); O(n, "onscript", n.script), n.script = "" } var t = n.tags.length, e = n.tagName; n.strict || (e = e[n.looseCase]()); for (var r = e; t--;) { if (n.tags[t].name === r) break; D(n, "Unexpected close tag") } if (t < 0) return D(n, "Unmatched closing tag: " + n.tagName), n.textNode += "</" + n.tagName + ">", void (n.state = A.TEXT); n.tagName = e; for (var i = n.tags.length; i-- > t;) { var a = n.tag = n.tags.pop(); n.tagName = n.tag.name, O(n, "onclosetag", n.tagName); var o = {}; for (var s in a.ns) o[s] = a.ns[s]; var u = n.tags[n.tags.length - 1] || n; n.opt.xmlns && a.ns !== u.ns && Object.keys(a.ns).forEach(function (t) { var e = a.ns[t]; O(n, "onclosenamespace", { prefix: t, uri: e }) }) } 0 === t && (n.closedRoot = !0), n.tagName = n.attribValue = n.attribName = "", n.attribList.length = 0, n.state = A.TEXT } function U(t) { var e, n = t.entity, r = n.toLowerCase(), i = ""; return t.ENTITIES[n] ? t.ENTITIES[n] : t.ENTITIES[r] ? t.ENTITIES[r] : ("#" === (n = r).charAt(0) && (i = "x" === n.charAt(1) ? (n = n.slice(2), (e = parseInt(n, 16)).toString(16)) : (n = n.slice(1), (e = parseInt(n, 10)).toString(10))), n = n.replace(/^0+/, ""), i.toLowerCase() !== n ? (D(t, "Invalid character entity"), "&" + t.entity + ";") : String.fromCodePoint(e)) } function j(t, e) { "<" === e ? (t.state = A.OPEN_WAKA, t.startTagPosition = t.position) : E(c, e) && (D(t, "Non-whitespace before first tag."), t.textNode = e, t.state = A.TEXT) } function z(t, e) { var n = ""; return e < t.length && (n = t.charAt(e)), n } function Z() { var t, e, n = [], r = -1, i = arguments.length; if (!i) return ""; for (var a = ""; ++r < i;) { var o = Number(arguments[r]); if (!isFinite(o) || o < 0 || 1114111 < o || S(o) !== o) throw RangeError("Invalid code point: " + o); o <= 65535 ? n.push(o) : (t = 55296 + ((o -= 65536) >> 10), e = o % 1024 + 56320, n.push(t, e)), (r + 1 === i || 16384 < n.length) && (a += T.apply(null, n), n.length = 0) } return a } A = u.STATE, String.fromCodePoint || (T = String.fromCharCode, S = Math.floor, Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", { value: Z, configurable: !0, writable: !0 }) : String.fromCodePoint = Z)
      }(e)
    }).call(this, H(1).Buffer)
  }, function (t, e) { }, function (t, e, n) { "use strict"; var s = n(8).Buffer, r = n(30); function i() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, i), this.head = null, this.tail = null, this.length = 0 } t.exports = (i.prototype.push = function (t) { var e = { data: t, next: null }; 0 < this.length ? this.tail.next = e : this.head = e, this.tail = e, ++this.length }, i.prototype.unshift = function (t) { var e = { data: t, next: this.head }; 0 === this.length && (this.tail = e), this.head = e, ++this.length }, i.prototype.shift = function () { if (0 !== this.length) { var t = this.head.data; return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, t } }, i.prototype.clear = function () { this.head = this.tail = null, this.length = 0 }, i.prototype.join = function (t) { if (0 === this.length) return ""; for (var e = this.head, n = "" + e.data; e = e.next;)n += t + e.data; return n }, i.prototype.concat = function (t) { if (0 === this.length) return s.alloc(0); if (1 === this.length) return this.head.data; for (var e, n, r, i = s.allocUnsafe(t >>> 0), a = this.head, o = 0; a;)e = a.data, n = i, r = o, e.copy(n, r), o += a.data.length, a = a.next; return i }, i), r && r.inspect && r.inspect.custom && (t.exports.prototype[r.inspect.custom] = function () { var t = r.inspect({ length: this.length }); return this.constructor.name + " " + t }) }, function (t, e) { }, function (t, i, a) { (function (t) { var e = void 0 !== t && t || "undefined" != typeof self && self || window, n = Function.prototype.apply; function r(t, e) { this._id = t, this._clearFn = e } i.setTimeout = function () { return new r(n.call(setTimeout, e, arguments), clearTimeout) }, i.setInterval = function () { return new r(n.call(setInterval, e, arguments), clearInterval) }, i.clearTimeout = i.clearInterval = function (t) { t && t.close() }, r.prototype.unref = r.prototype.ref = function () { }, r.prototype.close = function () { this._clearFn.call(e, this._id) }, i.enroll = function (t, e) { clearTimeout(t._idleTimeoutId), t._idleTimeout = e }, i.unenroll = function (t) { clearTimeout(t._idleTimeoutId), t._idleTimeout = -1 }, i._unrefActive = i.active = function (t) { clearTimeout(t._idleTimeoutId); var e = t._idleTimeout; 0 <= e && (t._idleTimeoutId = setTimeout(function () { t._onTimeout && t._onTimeout() }, e)) }, a(32), i.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== t && t.setImmediate || this && this.setImmediate, i.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== t && t.clearImmediate || this && this.clearImmediate }).call(this, a(2)) }, function (t, e, n) { (function (t, p) { !function (n, r) { "use strict"; if (!n.setImmediate) { var i, a, e, o, s = 1, u = {}, l = !1, c = n.document, t = Object.getPrototypeOf && Object.getPrototypeOf(n); t = t && t.setTimeout ? t : n, i = "[object process]" === {}.toString.call(n.process) ? function (t) { p.nextTick(function () { h(t) }) } : function () { if (n.postMessage && !n.importScripts) { var t = !0, e = n.onmessage; return n.onmessage = function () { t = !1 }, n.postMessage("", "*"), n.onmessage = e, t } }() ? (o = "setImmediate$" + Math.random() + "$", n.addEventListener ? n.addEventListener("message", d, !1) : n.attachEvent("onmessage", d), function (t) { n.postMessage(o + t, "*") }) : n.MessageChannel ? ((e = new MessageChannel).port1.onmessage = function (t) { h(t.data) }, function (t) { e.port2.postMessage(t) }) : c && "onreadystatechange" in c.createElement("script") ? (a = c.documentElement, function (t) { var e = c.createElement("script"); e.onreadystatechange = function () { h(t), e.onreadystatechange = null, a.removeChild(e), e = null }, a.appendChild(e) }) : function (t) { setTimeout(h, 0, t) }, t.setImmediate = function (t) { "function" != typeof t && (t = new Function("" + t)); for (var e = new Array(arguments.length - 1), n = 0; n < e.length; n++)e[n] = arguments[n + 1]; var r = { callback: t, args: e }; return u[s] = r, i(s), s++ }, t.clearImmediate = f } function f(t) { delete u[t] } function h(t) { if (l) setTimeout(h, 0, t); else { var e = u[t]; if (e) { l = !0; try { !function (t) { var e = t.callback, n = t.args; switch (n.length) { case 0: e(); break; case 1: e(n[0]); break; case 2: e(n[0], n[1]); break; case 3: e(n[0], n[1], n[2]); break; default: e.apply(r, n) } }(e) } finally { f(t), l = !1 } } } } function d(t) { t.source === n && "string" == typeof t.data && 0 === t.data.indexOf(o) && h(+t.data.slice(o.length)) } }("undefined" == typeof self ? void 0 === t ? this : t : self) }).call(this, n(2), n(0)) }, function (t, e, n) { (function (n) { function r(t) { try { if (!n.localStorage) return !1 } catch (t) { return !1 } var e = n.localStorage[t]; return null != e && "true" === String(e).toLowerCase() } t.exports = function (t, e) { if (r("noDeprecation")) return t; var n = !1; return function () { if (!n) { if (r("throwDeprecation")) throw new Error(e); r("traceDeprecation") ? console.trace(e) : console.warn(e), n = !0 } return t.apply(this, arguments) } } }).call(this, n(2)) }, function (t, e, n) { "use strict"; t.exports = a; var r = n(19), i = n(5); function a(t) { if (!(this instanceof a)) return new a(t); r.call(this, t) } i.inherits = n(3), i.inherits(a, r), a.prototype._transform = function (t, e, n) { n(null, t) } }, function (t, e, n) { t.exports = n(12) }, function (t, e, n) { t.exports = n(4) }, function (t, e, n) { t.exports = n(11).Transform }, function (t, e, n) { t.exports = n(11).PassThrough }, function (t, e) { }, function (t, O, x) { "use strict"; (function (i) { var _ = x(1).Buffer, o = x(15).Transform, s = x(41), t = x(21), b = x(20).ok, m = x(1).kMaxLength, y = "Cannot create final Buffer. It would be larger than 0x" + m.toString(16) + " bytes"; s.Z_MIN_WINDOWBITS = 8, s.Z_MAX_WINDOWBITS = 15, s.Z_DEFAULT_WINDOWBITS = 15, s.Z_MIN_CHUNK = 64, s.Z_MAX_CHUNK = 1 / 0, s.Z_DEFAULT_CHUNK = 16384, s.Z_MIN_MEMLEVEL = 1, s.Z_MAX_MEMLEVEL = 9, s.Z_DEFAULT_MEMLEVEL = 8, s.Z_MIN_LEVEL = -1, s.Z_MAX_LEVEL = 9, s.Z_DEFAULT_LEVEL = s.Z_DEFAULT_COMPRESSION; for (var e = Object.keys(s), n = 0; n < e.length; n++) { var r = e[n]; r.match(/^Z/) && Object.defineProperty(O, r, { enumerable: !0, value: s[r], writable: !1 }) } for (var a = { Z_OK: s.Z_OK, Z_STREAM_END: s.Z_STREAM_END, Z_NEED_DICT: s.Z_NEED_DICT, Z_ERRNO: s.Z_ERRNO, Z_STREAM_ERROR: s.Z_STREAM_ERROR, Z_DATA_ERROR: s.Z_DATA_ERROR, Z_MEM_ERROR: s.Z_MEM_ERROR, Z_BUF_ERROR: s.Z_BUF_ERROR, Z_VERSION_ERROR: s.Z_VERSION_ERROR }, u = Object.keys(a), l = 0; l < u.length; l++) { var c = u[l]; a[a[c]] = c } function f(n, t, r) { var i = [], a = 0; function e() { for (var t; null !== (t = n.read());)i.push(t), a += t.length; n.once("readable", e) } function o() { var t, e = null; m <= a ? e = new RangeError(y) : t = _.concat(i, a), i = [], n.close(), r(e, t) } n.on("error", function (t) { n.removeListener("end", o), n.removeListener("readable", e), r(t) }), n.on("end", o), n.end(t), e() } function h(t, e) { if ("string" == typeof e && (e = _.from(e)), !_.isBuffer(e)) throw new TypeError("Not a string or buffer"); var n = t._finishFlushFlag; return t._processChunk(e, n) } function d(t) { if (!(this instanceof d)) return new d(t); A.call(this, t, s.DEFLATE) } function p(t) { if (!(this instanceof p)) return new p(t); A.call(this, t, s.INFLATE) } function g(t) { if (!(this instanceof g)) return new g(t); A.call(this, t, s.GZIP) } function v(t) { if (!(this instanceof v)) return new v(t); A.call(this, t, s.GUNZIP) } function w(t) { if (!(this instanceof w)) return new w(t); A.call(this, t, s.DEFLATERAW) } function E(t) { if (!(this instanceof E)) return new E(t); A.call(this, t, s.INFLATERAW) } function T(t) { if (!(this instanceof T)) return new T(t); A.call(this, t, s.UNZIP) } function S(t) { return t === s.Z_NO_FLUSH || t === s.Z_PARTIAL_FLUSH || t === s.Z_SYNC_FLUSH || t === s.Z_FULL_FLUSH || t === s.Z_FINISH || t === s.Z_BLOCK } function A(t, e) { var n = this; if (this._opts = t = t || {}, this._chunkSize = t.chunkSize || O.Z_DEFAULT_CHUNK, o.call(this, t), t.flush && !S(t.flush)) throw new Error("Invalid flush flag: " + t.flush); if (t.finishFlush && !S(t.finishFlush)) throw new Error("Invalid flush flag: " + t.finishFlush); if (this._flushFlag = t.flush || s.Z_NO_FLUSH, this._finishFlushFlag = void 0 !== t.finishFlush ? t.finishFlush : s.Z_FINISH, t.chunkSize && (t.chunkSize < O.Z_MIN_CHUNK || t.chunkSize > O.Z_MAX_CHUNK)) throw new Error("Invalid chunk size: " + t.chunkSize); if (t.windowBits && (t.windowBits < O.Z_MIN_WINDOWBITS || t.windowBits > O.Z_MAX_WINDOWBITS)) throw new Error("Invalid windowBits: " + t.windowBits); if (t.level && (t.level < O.Z_MIN_LEVEL || t.level > O.Z_MAX_LEVEL)) throw new Error("Invalid compression level: " + t.level); if (t.memLevel && (t.memLevel < O.Z_MIN_MEMLEVEL || t.memLevel > O.Z_MAX_MEMLEVEL)) throw new Error("Invalid memLevel: " + t.memLevel); if (t.strategy && t.strategy != O.Z_FILTERED && t.strategy != O.Z_HUFFMAN_ONLY && t.strategy != O.Z_RLE && t.strategy != O.Z_FIXED && t.strategy != O.Z_DEFAULT_STRATEGY) throw new Error("Invalid strategy: " + t.strategy); if (t.dictionary && !_.isBuffer(t.dictionary)) throw new Error("Invalid dictionary: it should be a Buffer instance"); this._handle = new s.Zlib(e); var r = this; this._hadError = !1, this._handle.onerror = function (t, e) { k(r), r._hadError = !0; var n = new Error(t); n.errno = e, n.code = O.codes[e], r.emit("error", n) }; var i = O.Z_DEFAULT_COMPRESSION; "number" == typeof t.level && (i = t.level); var a = O.Z_DEFAULT_STRATEGY; "number" == typeof t.strategy && (a = t.strategy), this._handle.init(t.windowBits || O.Z_DEFAULT_WINDOWBITS, i, t.memLevel || O.Z_DEFAULT_MEMLEVEL, a, t.dictionary), this._buffer = _.allocUnsafe(this._chunkSize), this._offset = 0, this._level = i, this._strategy = a, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: function () { return !n._handle }, configurable: !0, enumerable: !0 }) } function k(t, e) { e && i.nextTick(e), t._handle && (t._handle.close(), t._handle = null) } function I(t) { t.emit("close") } Object.defineProperty(O, "codes", { enumerable: !0, value: Object.freeze(a), writable: !1 }), O.Deflate = d, O.Inflate = p, O.Gzip = g, O.Gunzip = v, O.DeflateRaw = w, O.InflateRaw = E, O.Unzip = T, O.createDeflate = function (t) { return new d(t) }, O.createInflate = function (t) { return new p(t) }, O.createDeflateRaw = function (t) { return new w(t) }, O.createInflateRaw = function (t) { return new E(t) }, O.createGzip = function (t) { return new g(t) }, O.createGunzip = function (t) { return new v(t) }, O.createUnzip = function (t) { return new T(t) }, O.deflate = function (t, e, n) { return "function" == typeof e && (n = e, e = {}), f(new d(e), t, n) }, O.deflateSync = function (t, e) { return h(new d(e), t) }, O.gzip = function (t, e, n) { return "function" == typeof e && (n = e, e = {}), f(new g(e), t, n) }, O.gzipSync = function (t, e) { return h(new g(e), t) }, O.deflateRaw = function (t, e, n) { return "function" == typeof e && (n = e, e = {}), f(new w(e), t, n) }, O.deflateRawSync = function (t, e) { return h(new w(e), t) }, O.unzip = function (t, e, n) { return "function" == typeof e && (n = e, e = {}), f(new T(e), t, n) }, O.unzipSync = function (t, e) { return h(new T(e), t) }, O.inflate = function (t, e, n) { return "function" == typeof e && (n = e, e = {}), f(new p(e), t, n) }, O.inflateSync = function (t, e) { return h(new p(e), t) }, O.gunzip = function (t, e, n) { return "function" == typeof e && (n = e, e = {}), f(new v(e), t, n) }, O.gunzipSync = function (t, e) { return h(new v(e), t) }, O.inflateRaw = function (t, e, n) { return "function" == typeof e && (n = e, e = {}), f(new E(e), t, n) }, O.inflateRawSync = function (t, e) { return h(new E(e), t) }, t.inherits(A, o), A.prototype.params = function (t, e, n) { if (t < O.Z_MIN_LEVEL || t > O.Z_MAX_LEVEL) throw new RangeError("Invalid compression level: " + t); if (e != O.Z_FILTERED && e != O.Z_HUFFMAN_ONLY && e != O.Z_RLE && e != O.Z_FIXED && e != O.Z_DEFAULT_STRATEGY) throw new TypeError("Invalid strategy: " + e); if (this._level !== t || this._strategy !== e) { var r = this; this.flush(s.Z_SYNC_FLUSH, function () { b(r._handle, "zlib binding closed"), r._handle.params(t, e), r._hadError || (r._level = t, r._strategy = e, n && n()) }) } else i.nextTick(n) }, A.prototype.reset = function () { return b(this._handle, "zlib binding closed"), this._handle.reset() }, A.prototype._flush = function (t) { this._transform(_.alloc(0), "", t) }, A.prototype.flush = function (t, e) { var n = this, r = this._writableState; "function" != typeof t && (void 0 !== t || e) || (e = t, t = s.Z_FULL_FLUSH), r.ended ? e && i.nextTick(e) : r.ending ? e && this.once("end", e) : r.needDrain ? e && this.once("drain", function () { return n.flush(t, e) }) : (this._flushFlag = t, this.write(_.alloc(0), "", e)) }, A.prototype.close = function (t) { k(this, t), i.nextTick(I, this) }, A.prototype._transform = function (t, e, n) { var r, i = this._writableState, a = (i.ending || i.ended) && (!t || i.length === t.length); return null === t || _.isBuffer(t) ? this._handle ? (a ? r = this._finishFlushFlag : (r = this._flushFlag, t.length >= i.length && (this._flushFlag = this._opts.flush || s.Z_NO_FLUSH)), void this._processChunk(t, r, n)) : n(new Error("zlib binding closed")) : n(new Error("invalid input")) }, A.prototype._processChunk = function (a, o, s) { var u = a && a.length, l = this._chunkSize - this._offset, c = 0, f = this, h = "function" == typeof s; if (!h) { var e, d = [], p = 0; this.on("error", function (t) { e = t }), b(this._handle, "zlib binding closed"); do { var t = this._handle.writeSync(o, a, c, u, this._buffer, this._offset, l) } while (!this._hadError && g(t[0], t[1])); if (this._hadError) throw e; if (m <= p) throw k(this), new RangeError(y); var n = _.concat(d, p); return k(this), n } b(this._handle, "zlib binding closed"); var r = this._handle.write(o, a, c, u, this._buffer, this._offset, l); function g(t, e) { if (this && (this.buffer = null, this.callback = null), !f._hadError) { var n = l - e; if (b(0 <= n, "have should not go down"), 0 < n) { var r = f._buffer.slice(f._offset, f._offset + n); f._offset += n, h ? f.push(r) : (d.push(r), p += r.length) } if ((0 === e || f._offset >= f._chunkSize) && (l = f._chunkSize, f._offset = 0, f._buffer = _.allocUnsafe(f._chunkSize)), 0 === e) { if (c += u - t, u = t, !h) return !0; var i = f._handle.write(o, a, c, u, f._buffer, f._offset, f._chunkSize); return i.callback = g, void (i.buffer = a) } if (!h) return !1; s() } } r.buffer = a, r.callback = g }, t.inherits(d, A), t.inherits(p, A), t.inherits(g, A), t.inherits(v, A), t.inherits(w, A), t.inherits(E, A), t.inherits(T, A) }).call(this, x(0)) }, function (t, h, r) { "use strict"; (function (l, c) { var f = r(20), a = r(43), o = r(44), s = r(47), t = r(50); for (var e in t) h[e] = t[e]; h.NONE = 0, h.DEFLATE = 1, h.INFLATE = 2, h.GZIP = 3, h.GUNZIP = 4, h.DEFLATERAW = 5, h.INFLATERAW = 6, h.UNZIP = 7; function n(t) { if ("number" != typeof t || t < h.DEFLATE || t > h.UNZIP) throw new TypeError("Bad argument"); this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = t, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0 } n.prototype.close = function () { this.write_in_progress ? this.pending_close = !0 : (this.pending_close = !1, f(this.init_done, "close before init"), f(this.mode <= h.UNZIP), this.mode === h.DEFLATE || this.mode === h.GZIP || this.mode === h.DEFLATERAW ? o.deflateEnd(this.strm) : this.mode !== h.INFLATE && this.mode !== h.GUNZIP && this.mode !== h.INFLATERAW && this.mode !== h.UNZIP || s.inflateEnd(this.strm), this.mode = h.NONE, this.dictionary = null) }, n.prototype.write = function (t, e, n, r, i, a, o) { return this._write(!0, t, e, n, r, i, a, o) }, n.prototype.writeSync = function (t, e, n, r, i, a, o) { return this._write(!1, t, e, n, r, i, a, o) }, n.prototype._write = function (t, e, n, r, i, a, o, s) { if (f.equal(arguments.length, 8), f(this.init_done, "write before init"), f(this.mode !== h.NONE, "already finalized"), f.equal(!1, this.write_in_progress, "write already in progress"), f.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, f.equal(!1, void 0 === e, "must provide flush value"), this.write_in_progress = !0, e !== h.Z_NO_FLUSH && e !== h.Z_PARTIAL_FLUSH && e !== h.Z_SYNC_FLUSH && e !== h.Z_FULL_FLUSH && e !== h.Z_FINISH && e !== h.Z_BLOCK) throw new Error("Invalid flush value"); if (null == n && (n = l.alloc(0), r = i = 0), this.strm.avail_in = i, this.strm.input = n, this.strm.next_in = r, this.strm.avail_out = s, this.strm.output = a, this.strm.next_out = o, this.flush = e, !t) return this._process(), this._checkError() ? this._afterSync() : void 0; var u = this; return c.nextTick(function () { u._process(), u._after() }), this }, n.prototype._afterSync = function () { var t = this.strm.avail_out, e = this.strm.avail_in; return this.write_in_progress = !1, [e, t] }, n.prototype._process = function () { var t = null; switch (this.mode) { case h.DEFLATE: case h.GZIP: case h.DEFLATERAW: this.err = o.deflate(this.strm, this.flush); break; case h.UNZIP: switch (0 < this.strm.avail_in && (t = this.strm.next_in), this.gzip_id_bytes_read) { case 0: if (null === t) break; if (31 !== this.strm.input[t]) { this.mode = h.INFLATE; break } if (t++ , (this.gzip_id_bytes_read = 1) === this.strm.avail_in) break; case 1: if (null === t) break; 139 === this.strm.input[t] ? (this.gzip_id_bytes_read = 2, this.mode = h.GUNZIP) : this.mode = h.INFLATE; break; default: throw new Error("invalid number of gzip magic number bytes read") }case h.INFLATE: case h.GUNZIP: case h.INFLATERAW: for (this.err = s.inflate(this.strm, this.flush), this.err === h.Z_NEED_DICT && this.dictionary && (this.err = s.inflateSetDictionary(this.strm, this.dictionary), this.err === h.Z_OK ? this.err = s.inflate(this.strm, this.flush) : this.err === h.Z_DATA_ERROR && (this.err = h.Z_NEED_DICT)); 0 < this.strm.avail_in && this.mode === h.GUNZIP && this.err === h.Z_STREAM_END && 0 !== this.strm.next_in[0];)this.reset(), this.err = s.inflate(this.strm, this.flush); break; default: throw new Error("Unknown mode " + this.mode) } }, n.prototype._checkError = function () { switch (this.err) { case h.Z_OK: case h.Z_BUF_ERROR: if (0 !== this.strm.avail_out && this.flush === h.Z_FINISH) return this._error("unexpected end of file"), !1; break; case h.Z_STREAM_END: break; case h.Z_NEED_DICT: return null == this.dictionary ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1; default: return this._error("Zlib error"), !1 }return !0 }, n.prototype._after = function () { if (this._checkError()) { var t = this.strm.avail_out, e = this.strm.avail_in; this.write_in_progress = !1, this.callback(e, t), this.pending_close && this.close() } }, n.prototype._error = function (t) { this.strm.msg && (t = this.strm.msg), this.onerror(t, this.err), this.write_in_progress = !1, this.pending_close && this.close() }, n.prototype.init = function (t, e, n, r, i) { f(4 === arguments.length || 5 === arguments.length, "init(windowBits, level, memLevel, strategy, [dictionary])"), f(8 <= t && t <= 15, "invalid windowBits"), f(-1 <= e && e <= 9, "invalid compression level"), f(1 <= n && n <= 9, "invalid memlevel"), f(r === h.Z_FILTERED || r === h.Z_HUFFMAN_ONLY || r === h.Z_RLE || r === h.Z_FIXED || r === h.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(e, t, n, r, i), this._setDictionary() }, n.prototype.params = function () { throw new Error("deflateParams Not supported") }, n.prototype.reset = function () { this._reset(), this._setDictionary() }, n.prototype._init = function (t, e, n, r, i) { switch (this.level = t, this.windowBits = e, this.memLevel = n, this.strategy = r, this.flush = h.Z_NO_FLUSH, this.err = h.Z_OK, this.mode !== h.GZIP && this.mode !== h.GUNZIP || (this.windowBits += 16), this.mode === h.UNZIP && (this.windowBits += 32), this.mode !== h.DEFLATERAW && this.mode !== h.INFLATERAW || (this.windowBits = -1 * this.windowBits), this.strm = new a, this.mode) { case h.DEFLATE: case h.GZIP: case h.DEFLATERAW: this.err = o.deflateInit2(this.strm, this.level, h.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy); break; case h.INFLATE: case h.GUNZIP: case h.INFLATERAW: case h.UNZIP: this.err = s.inflateInit2(this.strm, this.windowBits); break; default: throw new Error("Unknown mode " + this.mode) }this.err !== h.Z_OK && this._error("Init error"), this.dictionary = i, this.write_in_progress = !1, this.init_done = !0 }, n.prototype._setDictionary = function () { if (null != this.dictionary) { switch (this.err = h.Z_OK, this.mode) { case h.DEFLATE: case h.DEFLATERAW: this.err = o.deflateSetDictionary(this.strm, this.dictionary) }this.err !== h.Z_OK && this._error("Failed to set dictionary") } }, n.prototype._reset = function () { switch (this.err = h.Z_OK, this.mode) { case h.DEFLATE: case h.DEFLATERAW: case h.GZIP: this.err = o.deflateReset(this.strm); break; case h.INFLATE: case h.INFLATERAW: case h.GUNZIP: this.err = s.inflateReset(this.strm) }this.err !== h.Z_OK && this._error("Failed to reset stream") }, h.Zlib = n }).call(this, r(1).Buffer, r(0)) }, function (t, e) { t.exports = function (t) { return t && "object" == typeof t && "function" == typeof t.copy && "function" == typeof t.fill && "function" == typeof t.readUInt8 } }, function (t, e, n) { "use strict"; t.exports = function () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0 } }, function (t, e, n) { "use strict"; var u, h = n(9), l = n(45), d = n(22), p = n(23), r = n(46), c = 0, f = 4, g = 0, _ = -2, b = -1, m = 4, i = 2, y = 8, v = 9, a = 286, o = 30, s = 19, w = 2 * a + 1, E = 15, T = 3, S = 258, A = S + T + 1, k = 42, I = 113, O = 1, x = 2, R = 3, N = 4; function L(t, e) { return t.msg = r[e], e } function D(t) { return (t << 1) - (4 < t ? 9 : 0) } function P(t) { for (var e = t.length; 0 <= --e;)t[e] = 0 } function C(t) { var e = t.state, n = e.pending; n > t.avail_out && (n = t.avail_out), 0 !== n && (h.arraySet(t.output, e.pending_buf, e.pending_out, n, t.next_out), t.next_out += n, e.pending_out += n, t.total_out += n, t.avail_out -= n, e.pending -= n, 0 === e.pending && (e.pending_out = 0)) } function F(t, e) { l._tr_flush_block(t, 0 <= t.block_start ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, C(t.strm) } function M(t, e) { t.pending_buf[t.pending++] = e } function B(t, e) { t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e } function U(t, e) { var n, r, i = t.max_chain_length, a = t.strstart, o = t.prev_length, s = t.nice_match, u = t.strstart > t.w_size - A ? t.strstart - (t.w_size - A) : 0, l = t.window, c = t.w_mask, f = t.prev, h = t.strstart + S, d = l[a + o - 1], p = l[a + o]; t.prev_length >= t.good_match && (i >>= 2), s > t.lookahead && (s = t.lookahead); do { if (l[(n = e) + o] === p && l[n + o - 1] === d && l[n] === l[a] && l[++n] === l[a + 1]) { a += 2, n++; do { } while (l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && a < h); if (r = S - (h - a), a = h - S, o < r) { if (t.match_start = e, s <= (o = r)) break; d = l[a + o - 1], p = l[a + o] } } } while ((e = f[e & c]) > u && 0 != --i); return o <= t.lookahead ? o : t.lookahead } function j(t) { var e, n, r, i, a, o, s, u, l, c, f = t.w_size; do { if (i = t.window_size - t.lookahead - t.strstart, t.strstart >= f + (f - A)) { for (h.arraySet(t.window, t.window, f, f, 0), t.match_start -= f, t.strstart -= f, t.block_start -= f, e = n = t.hash_size; r = t.head[--e], t.head[e] = f <= r ? r - f : 0, --n;); for (e = n = f; r = t.prev[--e], t.prev[e] = f <= r ? r - f : 0, --n;); i += f } if (0 === t.strm.avail_in) break; if (o = t.strm, s = t.window, u = t.strstart + t.lookahead, l = i, c = void 0, c = o.avail_in, l < c && (c = l), n = 0 === c ? 0 : (o.avail_in -= c, h.arraySet(s, o.input, o.next_in, c, u), 1 === o.state.wrap ? o.adler = d(o.adler, s, c, u) : 2 === o.state.wrap && (o.adler = p(o.adler, s, c, u)), o.next_in += c, o.total_in += c, c), t.lookahead += n, t.lookahead + t.insert >= T) for (a = t.strstart - t.insert, t.ins_h = t.window[a], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[a + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[a + T - 1]) & t.hash_mask, t.prev[a & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = a, a++ , t.insert-- , !(t.lookahead + t.insert < T));); } while (t.lookahead < A && 0 !== t.strm.avail_in) } function z(t, e) { for (var n, r; ;) { if (t.lookahead < A) { if (j(t), t.lookahead < A && e === c) return O; if (0 === t.lookahead) break } if (n = 0, t.lookahead >= T && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + T - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== n && t.strstart - n <= t.w_size - A && (t.match_length = U(t, n)), t.match_length >= T) if (r = l._tr_tally(t, t.strstart - t.match_start, t.match_length - T), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= T) { for (t.match_length--; t.strstart++ , t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + T - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart, 0 != --t.match_length;); t.strstart++ } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask; else r = l._tr_tally(t, 0, t.window[t.strstart]), t.lookahead-- , t.strstart++; if (r && (F(t, !1), 0 === t.strm.avail_out)) return O } return t.insert = t.strstart < T - 1 ? t.strstart : T - 1, e === f ? (F(t, !0), 0 === t.strm.avail_out ? R : N) : t.last_lit && (F(t, !1), 0 === t.strm.avail_out) ? O : x } function Z(t, e) { for (var n, r, i; ;) { if (t.lookahead < A) { if (j(t), t.lookahead < A && e === c) return O; if (0 === t.lookahead) break } if (n = 0, t.lookahead >= T && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + T - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = T - 1, 0 !== n && t.prev_length < t.max_lazy_match && t.strstart - n <= t.w_size - A && (t.match_length = U(t, n), t.match_length <= 5 && (1 === t.strategy || t.match_length === T && 4096 < t.strstart - t.match_start) && (t.match_length = T - 1)), t.prev_length >= T && t.match_length <= t.prev_length) { for (i = t.strstart + t.lookahead - T, r = l._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - T), t.lookahead -= t.prev_length - 1, t.prev_length -= 2; ++t.strstart <= i && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + T - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 != --t.prev_length;); if (t.match_available = 0, t.match_length = T - 1, t.strstart++ , r && (F(t, !1), 0 === t.strm.avail_out)) return O } else if (t.match_available) { if ((r = l._tr_tally(t, 0, t.window[t.strstart - 1])) && F(t, !1), t.strstart++ , t.lookahead-- , 0 === t.strm.avail_out) return O } else t.match_available = 1, t.strstart++ , t.lookahead-- } return t.match_available && (r = l._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < T - 1 ? t.strstart : T - 1, e === f ? (F(t, !0), 0 === t.strm.avail_out ? R : N) : t.last_lit && (F(t, !1), 0 === t.strm.avail_out) ? O : x } function G(t, e, n, r, i) { this.good_length = t, this.max_lazy = e, this.nice_length = n, this.max_chain = r, this.func = i } function H() { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = y, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new h.Buf16(2 * w), this.dyn_dtree = new h.Buf16(2 * (2 * o + 1)), this.bl_tree = new h.Buf16(2 * (2 * s + 1)), P(this.dyn_ltree), P(this.dyn_dtree), P(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new h.Buf16(E + 1), this.heap = new h.Buf16(2 * a + 1), P(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new h.Buf16(2 * a + 1), P(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } function Y(t) { var e; return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = i, (e = t.state).pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? k : I, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = c, l._tr_init(e), g) : L(t, _) } function W(t) { var e = Y(t); return e === g && function (t) { t.window_size = 2 * t.w_size, P(t.head), t.max_lazy_match = u[t.level].max_lazy, t.good_match = u[t.level].good_length, t.nice_match = u[t.level].nice_length, t.max_chain_length = u[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = T - 1, t.match_available = 0, t.ins_h = 0 }(t.state), e } function q(t, e, n, r, i, a) { if (!t) return _; var o = 1; if (e === b && (e = 6), r < 0 ? (o = 0, r = -r) : 15 < r && (o = 2, r -= 16), i < 1 || v < i || n !== y || r < 8 || 15 < r || e < 0 || 9 < e || a < 0 || m < a) return L(t, _); 8 === r && (r = 9); var s = new H; return (t.state = s).strm = t, s.wrap = o, s.gzhead = null, s.w_bits = r, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = i + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + T - 1) / T), s.window = new h.Buf8(2 * s.w_size), s.head = new h.Buf16(s.hash_size), s.prev = new h.Buf16(s.w_size), s.lit_bufsize = 1 << i + 6, s.pending_buf_size = 4 * s.lit_bufsize, s.pending_buf = new h.Buf8(s.pending_buf_size), s.d_buf = 1 * s.lit_bufsize, s.l_buf = 3 * s.lit_bufsize, s.level = e, s.strategy = a, s.method = n, W(t) } u = [new G(0, 0, 0, 0, function (t, e) { var n = 65535; for (n > t.pending_buf_size - 5 && (n = t.pending_buf_size - 5); ;) { if (t.lookahead <= 1) { if (j(t), 0 === t.lookahead && e === c) return O; if (0 === t.lookahead) break } t.strstart += t.lookahead, t.lookahead = 0; var r = t.block_start + n; if ((0 === t.strstart || t.strstart >= r) && (t.lookahead = t.strstart - r, t.strstart = r, F(t, !1), 0 === t.strm.avail_out)) return O; if (t.strstart - t.block_start >= t.w_size - A && (F(t, !1), 0 === t.strm.avail_out)) return O } return t.insert = 0, e === f ? (F(t, !0), 0 === t.strm.avail_out ? R : N) : (t.strstart > t.block_start && (F(t, !1), t.strm.avail_out), O) }), new G(4, 4, 8, 4, z), new G(4, 5, 16, 8, z), new G(4, 6, 32, 32, z), new G(4, 4, 16, 16, Z), new G(8, 16, 32, 32, Z), new G(8, 16, 128, 128, Z), new G(8, 32, 128, 256, Z), new G(32, 128, 258, 1024, Z), new G(32, 258, 258, 4096, Z)], e.deflateInit = function (t, e) { return q(t, e, y, 15, 8, 0) }, e.deflateInit2 = q, e.deflateReset = W, e.deflateResetKeep = Y, e.deflateSetHeader = function (t, e) { return t && t.state ? 2 !== t.state.wrap ? _ : (t.state.gzhead = e, g) : _ }, e.deflate = function (t, e) { var n, r, i, a; if (!t || !t.state || 5 < e || e < 0) return t ? L(t, _) : _; if (r = t.state, !t.output || !t.input && 0 !== t.avail_in || 666 === r.status && e !== f) return L(t, 0 === t.avail_out ? -5 : _); if (r.strm = t, n = r.last_flush, r.last_flush = e, r.status === k) if (2 === r.wrap) t.adler = 0, M(r, 31), M(r, 139), M(r, 8), r.gzhead ? (M(r, (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)), M(r, 255 & r.gzhead.time), M(r, r.gzhead.time >> 8 & 255), M(r, r.gzhead.time >> 16 & 255), M(r, r.gzhead.time >> 24 & 255), M(r, 9 === r.level ? 2 : 2 <= r.strategy || r.level < 2 ? 4 : 0), M(r, 255 & r.gzhead.os), r.gzhead.extra && r.gzhead.extra.length && (M(r, 255 & r.gzhead.extra.length), M(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (t.adler = p(t.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = 69) : (M(r, 0), M(r, 0), M(r, 0), M(r, 0), M(r, 0), M(r, 9 === r.level ? 2 : 2 <= r.strategy || r.level < 2 ? 4 : 0), M(r, 3), r.status = I); else { var o = y + (r.w_bits - 8 << 4) << 8; o |= (2 <= r.strategy || r.level < 2 ? 0 : r.level < 6 ? 1 : 6 === r.level ? 2 : 3) << 6, 0 !== r.strstart && (o |= 32), o += 31 - o % 31, r.status = I, B(r, o), 0 !== r.strstart && (B(r, t.adler >>> 16), B(r, 65535 & t.adler)), t.adler = 1 } if (69 === r.status) if (r.gzhead.extra) { for (i = r.pending; r.gzindex < (65535 & r.gzhead.extra.length) && (r.pending !== r.pending_buf_size || (r.gzhead.hcrc && r.pending > i && (t.adler = p(t.adler, r.pending_buf, r.pending - i, i)), C(t), i = r.pending, r.pending !== r.pending_buf_size));)M(r, 255 & r.gzhead.extra[r.gzindex]), r.gzindex++; r.gzhead.hcrc && r.pending > i && (t.adler = p(t.adler, r.pending_buf, r.pending - i, i)), r.gzindex === r.gzhead.extra.length && (r.gzindex = 0, r.status = 73) } else r.status = 73; if (73 === r.status) if (r.gzhead.name) { i = r.pending; do { if (r.pending === r.pending_buf_size && (r.gzhead.hcrc && r.pending > i && (t.adler = p(t.adler, r.pending_buf, r.pending - i, i)), C(t), i = r.pending, r.pending === r.pending_buf_size)) { a = 1; break } a = r.gzindex < r.gzhead.name.length ? 255 & r.gzhead.name.charCodeAt(r.gzindex++) : 0, M(r, a) } while (0 !== a); r.gzhead.hcrc && r.pending > i && (t.adler = p(t.adler, r.pending_buf, r.pending - i, i)), 0 === a && (r.gzindex = 0, r.status = 91) } else r.status = 91; if (91 === r.status) if (r.gzhead.comment) { i = r.pending; do { if (r.pending === r.pending_buf_size && (r.gzhead.hcrc && r.pending > i && (t.adler = p(t.adler, r.pending_buf, r.pending - i, i)), C(t), i = r.pending, r.pending === r.pending_buf_size)) { a = 1; break } a = r.gzindex < r.gzhead.comment.length ? 255 & r.gzhead.comment.charCodeAt(r.gzindex++) : 0, M(r, a) } while (0 !== a); r.gzhead.hcrc && r.pending > i && (t.adler = p(t.adler, r.pending_buf, r.pending - i, i)), 0 === a && (r.status = 103) } else r.status = 103; if (103 === r.status && (r.gzhead.hcrc ? (r.pending + 2 > r.pending_buf_size && C(t), r.pending + 2 <= r.pending_buf_size && (M(r, 255 & t.adler), M(r, t.adler >> 8 & 255), t.adler = 0, r.status = I)) : r.status = I), 0 !== r.pending) { if (C(t), 0 === t.avail_out) return r.last_flush = -1, g } else if (0 === t.avail_in && D(e) <= D(n) && e !== f) return L(t, -5); if (666 === r.status && 0 !== t.avail_in) return L(t, -5); if (0 !== t.avail_in || 0 !== r.lookahead || e !== c && 666 !== r.status) { var s = 2 === r.strategy ? function (t, e) { for (var n; ;) { if (0 === t.lookahead && (j(t), 0 === t.lookahead)) { if (e === c) return O; break } if (t.match_length = 0, n = l._tr_tally(t, 0, t.window[t.strstart]), t.lookahead-- , t.strstart++ , n && (F(t, !1), 0 === t.strm.avail_out)) return O } return t.insert = 0, e === f ? (F(t, !0), 0 === t.strm.avail_out ? R : N) : t.last_lit && (F(t, !1), 0 === t.strm.avail_out) ? O : x }(r, e) : 3 === r.strategy ? function (t, e) { for (var n, r, i, a, o = t.window; ;) { if (t.lookahead <= S) { if (j(t), t.lookahead <= S && e === c) return O; if (0 === t.lookahead) break } if (t.match_length = 0, t.lookahead >= T && 0 < t.strstart && (r = o[i = t.strstart - 1]) === o[++i] && r === o[++i] && r === o[++i]) { a = t.strstart + S; do { } while (r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && i < a); t.match_length = S - (a - i), t.match_length > t.lookahead && (t.match_length = t.lookahead) } if (t.match_length >= T ? (n = l._tr_tally(t, 1, t.match_length - T), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (n = l._tr_tally(t, 0, t.window[t.strstart]), t.lookahead-- , t.strstart++), n && (F(t, !1), 0 === t.strm.avail_out)) return O } return t.insert = 0, e === f ? (F(t, !0), 0 === t.strm.avail_out ? R : N) : t.last_lit && (F(t, !1), 0 === t.strm.avail_out) ? O : x }(r, e) : u[r.level].func(r, e); if (s !== R && s !== N || (r.status = 666), s === O || s === R) return 0 === t.avail_out && (r.last_flush = -1), g; if (s === x && (1 === e ? l._tr_align(r) : 5 !== e && (l._tr_stored_block(r, 0, 0, !1), 3 === e && (P(r.head), 0 === r.lookahead && (r.strstart = 0, r.block_start = 0, r.insert = 0))), C(t), 0 === t.avail_out)) return r.last_flush = -1, g } return e !== f ? g : r.wrap <= 0 ? 1 : (2 === r.wrap ? (M(r, 255 & t.adler), M(r, t.adler >> 8 & 255), M(r, t.adler >> 16 & 255), M(r, t.adler >> 24 & 255), M(r, 255 & t.total_in), M(r, t.total_in >> 8 & 255), M(r, t.total_in >> 16 & 255), M(r, t.total_in >> 24 & 255)) : (B(r, t.adler >>> 16), B(r, 65535 & t.adler)), C(t), 0 < r.wrap && (r.wrap = -r.wrap), 0 !== r.pending ? g : 1) }, e.deflateEnd = function (t) { var e; return t && t.state ? (e = t.state.status) !== k && 69 !== e && 73 !== e && 91 !== e && 103 !== e && e !== I && 666 !== e ? L(t, _) : (t.state = null, e === I ? L(t, -3) : g) : _ }, e.deflateSetDictionary = function (t, e) { var n, r, i, a, o, s, u, l, c = e.length; if (!t || !t.state) return _; if (2 === (a = (n = t.state).wrap) || 1 === a && n.status !== k || n.lookahead) return _; for (1 === a && (t.adler = d(t.adler, e, c, 0)), n.wrap = 0, c >= n.w_size && (0 === a && (P(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0), l = new h.Buf8(n.w_size), h.arraySet(l, e, c - n.w_size, n.w_size, 0), e = l, c = n.w_size), o = t.avail_in, s = t.next_in, u = t.input, t.avail_in = c, t.next_in = 0, t.input = e, j(n); n.lookahead >= T;) { for (r = n.strstart, i = n.lookahead - (T - 1); n.ins_h = (n.ins_h << n.hash_shift ^ n.window[r + T - 1]) & n.hash_mask, n.prev[r & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = r, r++ , --i;); n.strstart = r, n.lookahead = T - 1, j(n) } return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = T - 1, n.match_available = 0, t.next_in = s, t.input = u, t.avail_in = o, n.wrap = a, g }, e.deflateInfo = "pako deflate (from Nodeca project)" }, function (t, e, n) { "use strict"; var i = n(9), s = 0, u = 1; function r(t) { for (var e = t.length; 0 <= --e;)t[e] = 0 } var a = 0, o = 29, l = 256, c = l + 1 + o, f = 30, h = 19, _ = 2 * c + 1, b = 15, d = 16, p = 7, g = 256, m = 16, y = 17, v = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], E = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], T = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], A = new Array(2 * (c + 2)); r(A); var k = new Array(2 * f); r(k); var I = new Array(512); r(I); var O = new Array(256); r(O); var x = new Array(o); r(x); var R, N, L, D = new Array(f); function P(t, e, n, r, i) { this.static_tree = t, this.extra_bits = e, this.extra_base = n, this.elems = r, this.max_length = i, this.has_stree = t && t.length } function C(t, e) { this.dyn_tree = t, this.max_code = 0, this.stat_desc = e } function F(t) { return t < 256 ? I[t] : I[256 + (t >>> 7)] } function M(t, e) { t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255 } function B(t, e, n) { t.bi_valid > d - n ? (t.bi_buf |= e << t.bi_valid & 65535, M(t, t.bi_buf), t.bi_buf = e >> d - t.bi_valid, t.bi_valid += n - d) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += n) } function U(t, e, n) { B(t, n[2 * e], n[2 * e + 1]) } function j(t, e) { for (var n = 0; n |= 1 & t, t >>>= 1, n <<= 1, 0 < --e;); return n >>> 1 } function z(t, e, n) { var r, i, a = new Array(b + 1), o = 0; for (r = 1; r <= b; r++)a[r] = o = o + n[r - 1] << 1; for (i = 0; i <= e; i++) { var s = t[2 * i + 1]; 0 !== s && (t[2 * i] = j(a[s]++, s)) } } function Z(t) { var e; for (e = 0; e < c; e++)t.dyn_ltree[2 * e] = 0; for (e = 0; e < f; e++)t.dyn_dtree[2 * e] = 0; for (e = 0; e < h; e++)t.bl_tree[2 * e] = 0; t.dyn_ltree[2 * g] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0 } function G(t) { 8 < t.bi_valid ? M(t, t.bi_buf) : 0 < t.bi_valid && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0 } function H(t, e, n, r) { var i = 2 * e, a = 2 * n; return t[i] < t[a] || t[i] === t[a] && r[e] <= r[n] } function Y(t, e, n) { for (var r = t.heap[n], i = n << 1; i <= t.heap_len && (i < t.heap_len && H(e, t.heap[i + 1], t.heap[i], t.depth) && i++ , !H(e, r, t.heap[i], t.depth));)t.heap[n] = t.heap[i], n = i, i <<= 1; t.heap[n] = r } function W(t, e, n) { var r, i, a, o, s = 0; if (0 !== t.last_lit) for (; r = t.pending_buf[t.d_buf + 2 * s] << 8 | t.pending_buf[t.d_buf + 2 * s + 1], i = t.pending_buf[t.l_buf + s], s++ , 0 === r ? U(t, i, e) : (U(t, (a = O[i]) + l + 1, e), 0 !== (o = w[a]) && B(t, i -= x[a], o), U(t, a = F(--r), n), 0 !== (o = E[a]) && B(t, r -= D[a], o)), s < t.last_lit;); U(t, g, e) } function q(t, e) { var n, r, i, a = e.dyn_tree, o = e.stat_desc.static_tree, s = e.stat_desc.has_stree, u = e.stat_desc.elems, l = -1; for (t.heap_len = 0, t.heap_max = _, n = 0; n < u; n++)0 !== a[2 * n] ? (t.heap[++t.heap_len] = l = n, t.depth[n] = 0) : a[2 * n + 1] = 0; for (; t.heap_len < 2;)a[2 * (i = t.heap[++t.heap_len] = l < 2 ? ++l : 0)] = 1, t.depth[i] = 0, t.opt_len-- , s && (t.static_len -= o[2 * i + 1]); for (e.max_code = l, n = t.heap_len >> 1; 1 <= n; n--)Y(t, a, n); for (i = u; n = t.heap[1], t.heap[1] = t.heap[t.heap_len--], Y(t, a, 1), r = t.heap[1], t.heap[--t.heap_max] = n, t.heap[--t.heap_max] = r, a[2 * i] = a[2 * n] + a[2 * r], t.depth[i] = (t.depth[n] >= t.depth[r] ? t.depth[n] : t.depth[r]) + 1, a[2 * n + 1] = a[2 * r + 1] = i, t.heap[1] = i++ , Y(t, a, 1), 2 <= t.heap_len;); t.heap[--t.heap_max] = t.heap[1], function (t, e) { var n, r, i, a, o, s, u = e.dyn_tree, l = e.max_code, c = e.stat_desc.static_tree, f = e.stat_desc.has_stree, h = e.stat_desc.extra_bits, d = e.stat_desc.extra_base, p = e.stat_desc.max_length, g = 0; for (a = 0; a <= b; a++)t.bl_count[a] = 0; for (u[2 * t.heap[t.heap_max] + 1] = 0, n = t.heap_max + 1; n < _; n++)p < (a = u[2 * u[2 * (r = t.heap[n]) + 1] + 1] + 1) && (a = p, g++), u[2 * r + 1] = a, l < r || (t.bl_count[a]++ , o = 0, d <= r && (o = h[r - d]), s = u[2 * r], t.opt_len += s * (a + o), f && (t.static_len += s * (c[2 * r + 1] + o))); if (0 !== g) { do { for (a = p - 1; 0 === t.bl_count[a];)a--; t.bl_count[a]-- , t.bl_count[a + 1] += 2, t.bl_count[p]-- , g -= 2 } while (0 < g); for (a = p; 0 !== a; a--)for (r = t.bl_count[a]; 0 !== r;)l < (i = t.heap[--n]) || (u[2 * i + 1] !== a && (t.opt_len += (a - u[2 * i + 1]) * u[2 * i], u[2 * i + 1] = a), r--) } }(t, e), z(a, l, t.bl_count) } function V(t, e, n) { var r, i, a = -1, o = e[1], s = 0, u = 7, l = 4; for (0 === o && (u = 138, l = 3), e[2 * (n + 1) + 1] = 65535, r = 0; r <= n; r++)i = o, o = e[2 * (r + 1) + 1], ++s < u && i === o || (s < l ? t.bl_tree[2 * i] += s : 0 !== i ? (i !== a && t.bl_tree[2 * i]++ , t.bl_tree[2 * m]++) : s <= 10 ? t.bl_tree[2 * y]++ : t.bl_tree[2 * v]++ , a = i, l = (s = 0) === o ? (u = 138, 3) : i === o ? (u = 6, 3) : (u = 7, 4)) } function X(t, e, n) { var r, i, a = -1, o = e[1], s = 0, u = 7, l = 4; for (0 === o && (u = 138, l = 3), r = 0; r <= n; r++)if (i = o, o = e[2 * (r + 1) + 1], !(++s < u && i === o)) { if (s < l) for (; U(t, i, t.bl_tree), 0 != --s;); else 0 !== i ? (i !== a && (U(t, i, t.bl_tree), s--), U(t, m, t.bl_tree), B(t, s - 3, 2)) : s <= 10 ? (U(t, y, t.bl_tree), B(t, s - 3, 3)) : (U(t, v, t.bl_tree), B(t, s - 11, 7)); a = i, l = (s = 0) === o ? (u = 138, 3) : i === o ? (u = 6, 3) : (u = 7, 4) } } r(D); var K = !1; function Q(t, e, n, r) { B(t, (a << 1) + (r ? 1 : 0), 3), function (t, e, n, r) { G(t), r && (M(t, n), M(t, ~n)), i.arraySet(t.pending_buf, t.window, e, n, t.pending), t.pending += n }(t, e, n, !0) } e._tr_init = function (t) { K || (function () { var t, e, n, r, i, a = new Array(b + 1); for (r = n = 0; r < o - 1; r++)for (x[r] = n, t = 0; t < 1 << w[r]; t++)O[n++] = r; for (O[n - 1] = r, r = i = 0; r < 16; r++)for (D[r] = i, t = 0; t < 1 << E[r]; t++)I[i++] = r; for (i >>= 7; r < f; r++)for (D[r] = i << 7, t = 0; t < 1 << E[r] - 7; t++)I[256 + i++] = r; for (e = 0; e <= b; e++)a[e] = 0; for (t = 0; t <= 143;)A[2 * t + 1] = 8, t++ , a[8]++; for (; t <= 255;)A[2 * t + 1] = 9, t++ , a[9]++; for (; t <= 279;)A[2 * t + 1] = 7, t++ , a[7]++; for (; t <= 287;)A[2 * t + 1] = 8, t++ , a[8]++; for (z(A, c + 1, a), t = 0; t < f; t++)k[2 * t + 1] = 5, k[2 * t] = j(t, 5); R = new P(A, w, l + 1, c, b), N = new P(k, E, 0, f, b), L = new P(new Array(0), T, 0, h, p) }(), K = !0), t.l_desc = new C(t.dyn_ltree, R), t.d_desc = new C(t.dyn_dtree, N), t.bl_desc = new C(t.bl_tree, L), t.bi_buf = 0, t.bi_valid = 0, Z(t) }, e._tr_stored_block = Q, e._tr_flush_block = function (t, e, n, r) { var i, a, o = 0; 0 < t.level ? (2 === t.strm.data_type && (t.strm.data_type = function (t) { var e, n = 4093624447; for (e = 0; e <= 31; e++ , n >>>= 1)if (1 & n && 0 !== t.dyn_ltree[2 * e]) return s; if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return u; for (e = 32; e < l; e++)if (0 !== t.dyn_ltree[2 * e]) return u; return s }(t)), q(t, t.l_desc), q(t, t.d_desc), o = function (t) { var e; for (V(t, t.dyn_ltree, t.l_desc.max_code), V(t, t.dyn_dtree, t.d_desc.max_code), q(t, t.bl_desc), e = h - 1; 3 <= e && 0 === t.bl_tree[2 * S[e] + 1]; e--); return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e }(t), i = t.opt_len + 3 + 7 >>> 3, (a = t.static_len + 3 + 7 >>> 3) <= i && (i = a)) : i = a = n + 5, n + 4 <= i && -1 !== e ? Q(t, e, n, r) : 4 === t.strategy || a === i ? (B(t, 2 + (r ? 1 : 0), 3), W(t, A, k)) : (B(t, 4 + (r ? 1 : 0), 3), function (t, e, n, r) { var i; for (B(t, e - 257, 5), B(t, n - 1, 5), B(t, r - 4, 4), i = 0; i < r; i++)B(t, t.bl_tree[2 * S[i] + 1], 3); X(t, t.dyn_ltree, e - 1), X(t, t.dyn_dtree, n - 1) }(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, o + 1), W(t, t.dyn_ltree, t.dyn_dtree)), Z(t), r && G(t) }, e._tr_tally = function (t, e, n) { return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & n, t.last_lit++ , 0 === e ? t.dyn_ltree[2 * n]++ : (t.matches++ , e-- , t.dyn_ltree[2 * (O[n] + l + 1)]++ , t.dyn_dtree[2 * F(e)]++), t.last_lit === t.lit_bufsize - 1 }, e._tr_align = function (t) { B(t, 2, 3), U(t, g, A), function (t) { 16 === t.bi_valid ? (M(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : 8 <= t.bi_valid && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8) }(t) } }, function (t, e, n) { "use strict"; t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" } }, function (t, e, n) { "use strict"; var x = n(9), R = n(22), N = n(23), L = n(48), D = n(49), P = 1, C = 2, F = 0, M = -2, B = 1, r = 852, i = 592; function U(t) { return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24) } function a() { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new x.Buf16(320), this.work = new x.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0 } function o(t) { var e; return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = B, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new x.Buf32(r), e.distcode = e.distdyn = new x.Buf32(i), e.sane = 1, e.back = -1, F) : M } function s(t) { var e; return t && t.state ? ((e = t.state).wsize = 0, e.whave = 0, e.wnext = 0, o(t)) : M } function u(t, e) { var n, r; return t && t.state ? (r = t.state, e < 0 ? (n = 0, e = -e) : (n = 1 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || 15 < e) ? M : (null !== r.window && r.wbits !== e && (r.window = null), r.wrap = n, r.wbits = e, s(t))) : M } function l(t, e) { var n, r; return t ? (r = new a, (t.state = r).window = null, (n = u(t, e)) !== F && (t.state = null), n) : M } var c, f, h = !0; function j(t) { if (h) { var e; for (c = new x.Buf32(512), f = new x.Buf32(32), e = 0; e < 144;)t.lens[e++] = 8; for (; e < 256;)t.lens[e++] = 9; for (; e < 280;)t.lens[e++] = 7; for (; e < 288;)t.lens[e++] = 8; for (D(P, t.lens, 0, 288, c, 0, t.work, { bits: 9 }), e = 0; e < 32;)t.lens[e++] = 5; D(C, t.lens, 0, 32, f, 0, t.work, { bits: 5 }), h = !1 } t.lencode = c, t.lenbits = 9, t.distcode = f, t.distbits = 5 } function z(t, e, n, r) { var i, a = t.state; return null === a.window && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new x.Buf8(a.wsize)), r >= a.wsize ? (x.arraySet(a.window, e, n - a.wsize, a.wsize, 0), a.wnext = 0, a.whave = a.wsize) : (r < (i = a.wsize - a.wnext) && (i = r), x.arraySet(a.window, e, n - r, i, a.wnext), (r -= i) ? (x.arraySet(a.window, e, n - r, r, 0), a.wnext = r, a.whave = a.wsize) : (a.wnext += i, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += i))), 0 } e.inflateReset = s, e.inflateReset2 = u, e.inflateResetKeep = o, e.inflateInit = function (t) { return l(t, 15) }, e.inflateInit2 = l, e.inflate = function (t, e) { var n, r, i, a, o, s, u, l, c, f, h, d, p, g, _, b, m, y, v, w, E, T, S, A, k = 0, I = new x.Buf8(4), O = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return M; 12 === (n = t.state).mode && (n.mode = 13), o = t.next_out, i = t.output, u = t.avail_out, a = t.next_in, r = t.input, s = t.avail_in, l = n.hold, c = n.bits, f = s, h = u, T = F; t: for (; ;)switch (n.mode) { case B: if (0 === n.wrap) { n.mode = 13; break } for (; c < 16;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } if (2 & n.wrap && 35615 === l) { I[n.check = 0] = 255 & l, I[1] = l >>> 8 & 255, n.check = N(n.check, I, 2, 0), c = l = 0, n.mode = 2; break } if (n.flags = 0, n.head && (n.head.done = !1), !(1 & n.wrap) || (((255 & l) << 8) + (l >> 8)) % 31) { t.msg = "incorrect header check", n.mode = 30; break } if (8 != (15 & l)) { t.msg = "unknown compression method", n.mode = 30; break } if (c -= 4, E = 8 + (15 & (l >>>= 4)), 0 === n.wbits) n.wbits = E; else if (E > n.wbits) { t.msg = "invalid window size", n.mode = 30; break } n.dmax = 1 << E, t.adler = n.check = 1, n.mode = 512 & l ? 10 : 12, c = l = 0; break; case 2: for (; c < 16;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } if (n.flags = l, 8 != (255 & n.flags)) { t.msg = "unknown compression method", n.mode = 30; break } if (57344 & n.flags) { t.msg = "unknown header flags set", n.mode = 30; break } n.head && (n.head.text = l >> 8 & 1), 512 & n.flags && (I[0] = 255 & l, I[1] = l >>> 8 & 255, n.check = N(n.check, I, 2, 0)), c = l = 0, n.mode = 3; case 3: for (; c < 32;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } n.head && (n.head.time = l), 512 & n.flags && (I[0] = 255 & l, I[1] = l >>> 8 & 255, I[2] = l >>> 16 & 255, I[3] = l >>> 24 & 255, n.check = N(n.check, I, 4, 0)), c = l = 0, n.mode = 4; case 4: for (; c < 16;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } n.head && (n.head.xflags = 255 & l, n.head.os = l >> 8), 512 & n.flags && (I[0] = 255 & l, I[1] = l >>> 8 & 255, n.check = N(n.check, I, 2, 0)), c = l = 0, n.mode = 5; case 5: if (1024 & n.flags) { for (; c < 16;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } n.length = l, n.head && (n.head.extra_len = l), 512 & n.flags && (I[0] = 255 & l, I[1] = l >>> 8 & 255, n.check = N(n.check, I, 2, 0)), c = l = 0 } else n.head && (n.head.extra = null); n.mode = 6; case 6: if (1024 & n.flags && (s < (d = n.length) && (d = s), d && (n.head && (E = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Array(n.head.extra_len)), x.arraySet(n.head.extra, r, a, d, E)), 512 & n.flags && (n.check = N(n.check, r, d, a)), s -= d, a += d, n.length -= d), n.length)) break t; n.length = 0, n.mode = 7; case 7: if (2048 & n.flags) { if (0 === s) break t; for (d = 0; E = r[a + d++], n.head && E && n.length < 65536 && (n.head.name += String.fromCharCode(E)), E && d < s;); if (512 & n.flags && (n.check = N(n.check, r, d, a)), s -= d, a += d, E) break t } else n.head && (n.head.name = null); n.length = 0, n.mode = 8; case 8: if (4096 & n.flags) { if (0 === s) break t; for (d = 0; E = r[a + d++], n.head && E && n.length < 65536 && (n.head.comment += String.fromCharCode(E)), E && d < s;); if (512 & n.flags && (n.check = N(n.check, r, d, a)), s -= d, a += d, E) break t } else n.head && (n.head.comment = null); n.mode = 9; case 9: if (512 & n.flags) { for (; c < 16;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } if (l !== (65535 & n.check)) { t.msg = "header crc mismatch", n.mode = 30; break } c = l = 0 } n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), t.adler = n.check = 0, n.mode = 12; break; case 10: for (; c < 32;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } t.adler = n.check = U(l), c = l = 0, n.mode = 11; case 11: if (0 === n.havedict) return t.next_out = o, t.avail_out = u, t.next_in = a, t.avail_in = s, n.hold = l, n.bits = c, 2; t.adler = n.check = 1, n.mode = 12; case 12: if (5 === e || 6 === e) break t; case 13: if (n.last) { l >>>= 7 & c, c -= 7 & c, n.mode = 27; break } for (; c < 3;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } switch (n.last = 1 & l, c -= 1, 3 & (l >>>= 1)) { case 0: n.mode = 14; break; case 1: if (j(n), n.mode = 20, 6 !== e) break; l >>>= 2, c -= 2; break t; case 2: n.mode = 17; break; case 3: t.msg = "invalid block type", n.mode = 30 }l >>>= 2, c -= 2; break; case 14: for (l >>>= 7 & c, c -= 7 & c; c < 32;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } if ((65535 & l) != (l >>> 16 ^ 65535)) { t.msg = "invalid stored block lengths", n.mode = 30; break } if (n.length = 65535 & l, c = l = 0, n.mode = 15, 6 === e) break t; case 15: n.mode = 16; case 16: if (d = n.length) { if (s < d && (d = s), u < d && (d = u), 0 === d) break t; x.arraySet(i, r, a, d, o), s -= d, a += d, u -= d, o += d, n.length -= d; break } n.mode = 12; break; case 17: for (; c < 14;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } if (n.nlen = 257 + (31 & l), l >>>= 5, c -= 5, n.ndist = 1 + (31 & l), l >>>= 5, c -= 5, n.ncode = 4 + (15 & l), l >>>= 4, c -= 4, 286 < n.nlen || 30 < n.ndist) { t.msg = "too many length or distance symbols", n.mode = 30; break } n.have = 0, n.mode = 18; case 18: for (; n.have < n.ncode;) { for (; c < 3;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } n.lens[O[n.have++]] = 7 & l, l >>>= 3, c -= 3 } for (; n.have < 19;)n.lens[O[n.have++]] = 0; if (n.lencode = n.lendyn, n.lenbits = 7, S = { bits: n.lenbits }, T = D(0, n.lens, 0, 19, n.lencode, 0, n.work, S), n.lenbits = S.bits, T) { t.msg = "invalid code lengths set", n.mode = 30; break } n.have = 0, n.mode = 19; case 19: for (; n.have < n.nlen + n.ndist;) { for (; b = (k = n.lencode[l & (1 << n.lenbits) - 1]) >>> 16 & 255, m = 65535 & k, !((_ = k >>> 24) <= c);) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } if (m < 16) l >>>= _, c -= _, n.lens[n.have++] = m; else { if (16 === m) { for (A = _ + 2; c < A;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } if (l >>>= _, c -= _, 0 === n.have) { t.msg = "invalid bit length repeat", n.mode = 30; break } E = n.lens[n.have - 1], d = 3 + (3 & l), l >>>= 2, c -= 2 } else if (17 === m) { for (A = _ + 3; c < A;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } c -= _, E = 0, d = 3 + (7 & (l >>>= _)), l >>>= 3, c -= 3 } else { for (A = _ + 7; c < A;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } c -= _, E = 0, d = 11 + (127 & (l >>>= _)), l >>>= 7, c -= 7 } if (n.have + d > n.nlen + n.ndist) { t.msg = "invalid bit length repeat", n.mode = 30; break } for (; d--;)n.lens[n.have++] = E } } if (30 === n.mode) break; if (0 === n.lens[256]) { t.msg = "invalid code -- missing end-of-block", n.mode = 30; break } if (n.lenbits = 9, S = { bits: n.lenbits }, T = D(P, n.lens, 0, n.nlen, n.lencode, 0, n.work, S), n.lenbits = S.bits, T) { t.msg = "invalid literal/lengths set", n.mode = 30; break } if (n.distbits = 6, n.distcode = n.distdyn, S = { bits: n.distbits }, T = D(C, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, S), n.distbits = S.bits, T) { t.msg = "invalid distances set", n.mode = 30; break } if (n.mode = 20, 6 === e) break t; case 20: n.mode = 21; case 21: if (6 <= s && 258 <= u) { t.next_out = o, t.avail_out = u, t.next_in = a, t.avail_in = s, n.hold = l, n.bits = c, L(t, h), o = t.next_out, i = t.output, u = t.avail_out, a = t.next_in, r = t.input, s = t.avail_in, l = n.hold, c = n.bits, 12 === n.mode && (n.back = -1); break } for (n.back = 0; b = (k = n.lencode[l & (1 << n.lenbits) - 1]) >>> 16 & 255, m = 65535 & k, !((_ = k >>> 24) <= c);) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } if (b && 0 == (240 & b)) { for (y = _, v = b, w = m; b = (k = n.lencode[w + ((l & (1 << y + v) - 1) >> y)]) >>> 16 & 255, m = 65535 & k, !(y + (_ = k >>> 24) <= c);) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } l >>>= y, c -= y, n.back += y } if (l >>>= _, c -= _, n.back += _, n.length = m, 0 === b) { n.mode = 26; break } if (32 & b) { n.back = -1, n.mode = 12; break } if (64 & b) { t.msg = "invalid literal/length code", n.mode = 30; break } n.extra = 15 & b, n.mode = 22; case 22: if (n.extra) { for (A = n.extra; c < A;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } n.length += l & (1 << n.extra) - 1, l >>>= n.extra, c -= n.extra, n.back += n.extra } n.was = n.length, n.mode = 23; case 23: for (; b = (k = n.distcode[l & (1 << n.distbits) - 1]) >>> 16 & 255, m = 65535 & k, !((_ = k >>> 24) <= c);) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } if (0 == (240 & b)) { for (y = _, v = b, w = m; b = (k = n.distcode[w + ((l & (1 << y + v) - 1) >> y)]) >>> 16 & 255, m = 65535 & k, !(y + (_ = k >>> 24) <= c);) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } l >>>= y, c -= y, n.back += y } if (l >>>= _, c -= _, n.back += _, 64 & b) { t.msg = "invalid distance code", n.mode = 30; break } n.offset = m, n.extra = 15 & b, n.mode = 24; case 24: if (n.extra) { for (A = n.extra; c < A;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } n.offset += l & (1 << n.extra) - 1, l >>>= n.extra, c -= n.extra, n.back += n.extra } if (n.offset > n.dmax) { t.msg = "invalid distance too far back", n.mode = 30; break } n.mode = 25; case 25: if (0 === u) break t; if (d = h - u, n.offset > d) { if ((d = n.offset - d) > n.whave && n.sane) { t.msg = "invalid distance too far back", n.mode = 30; break } p = d > n.wnext ? (d -= n.wnext, n.wsize - d) : n.wnext - d, d > n.length && (d = n.length), g = n.window } else g = i, p = o - n.offset, d = n.length; for (u < d && (d = u), u -= d, n.length -= d; i[o++] = g[p++], --d;); 0 === n.length && (n.mode = 21); break; case 26: if (0 === u) break t; i[o++] = n.length, u-- , n.mode = 21; break; case 27: if (n.wrap) { for (; c < 32;) { if (0 === s) break t; s-- , l |= r[a++] << c, c += 8 } if (h -= u, t.total_out += h, n.total += h, h && (t.adler = n.check = n.flags ? N(n.check, i, h, o - h) : R(n.check, i, h, o - h)), h = u, (n.flags ? l : U(l)) !== n.check) { t.msg = "incorrect data check", n.mode = 30; break } c = l = 0 } n.mode = 28; case 28: if (n.wrap && n.flags) { for (; c < 32;) { if (0 === s) break t; s-- , l += r[a++] << c, c += 8 } if (l !== (4294967295 & n.total)) { t.msg = "incorrect length check", n.mode = 30; break } c = l = 0 } n.mode = 29; case 29: T = 1; break t; case 30: T = -3; break t; case 31: return -4; case 32: default: return M }return t.next_out = o, t.avail_out = u, t.next_in = a, t.avail_in = s, n.hold = l, n.bits = c, (n.wsize || h !== t.avail_out && n.mode < 30 && (n.mode < 27 || 4 !== e)) && z(t, t.output, t.next_out, h - t.avail_out) ? (n.mode = 31, -4) : (f -= t.avail_in, h -= t.avail_out, t.total_in += f, t.total_out += h, n.total += h, n.wrap && h && (t.adler = n.check = n.flags ? N(n.check, i, h, t.next_out - h) : R(n.check, i, h, t.next_out - h)), t.data_type = n.bits + (n.last ? 64 : 0) + (12 === n.mode ? 128 : 0) + (20 === n.mode || 15 === n.mode ? 256 : 0), (0 == f && 0 === h || 4 === e) && T === F && (T = -5), T) }, e.inflateEnd = function (t) { if (!t || !t.state) return M; var e = t.state; return e.window && (e.window = null), t.state = null, F }, e.inflateGetHeader = function (t, e) { var n; return t && t.state ? 0 == (2 & (n = t.state).wrap) ? M : ((n.head = e).done = !1, F) : M }, e.inflateSetDictionary = function (t, e) { var n, r = e.length; return t && t.state ? 0 !== (n = t.state).wrap && 11 !== n.mode ? M : 11 === n.mode && R(1, e, r, 0) !== n.check ? -3 : z(t, e, r, r) ? (n.mode = 31, -4) : (n.havedict = 1, F) : M }, e.inflateInfo = "pako inflate (from Nodeca project)" }, function (t, e, n) { "use strict"; t.exports = function (t, e) { var n, r, i, a, o, s, u, l, c, f, h, d, p, g, _, b, m, y, v, w, E, T, S, A, k; n = t.state, r = t.next_in, A = t.input, i = r + (t.avail_in - 5), a = t.next_out, k = t.output, o = a - (e - t.avail_out), s = a + (t.avail_out - 257), u = n.dmax, l = n.wsize, c = n.whave, f = n.wnext, h = n.window, d = n.hold, p = n.bits, g = n.lencode, _ = n.distcode, b = (1 << n.lenbits) - 1, m = (1 << n.distbits) - 1; t: do { p < 15 && (d += A[r++] << p, p += 8, d += A[r++] << p, p += 8), y = g[d & b]; e: for (; ;) { if (d >>>= v = y >>> 24, p -= v, 0 === (v = y >>> 16 & 255)) k[a++] = 65535 & y; else { if (!(16 & v)) { if (0 == (64 & v)) { y = g[(65535 & y) + (d & (1 << v) - 1)]; continue e } if (32 & v) { n.mode = 12; break t } t.msg = "invalid literal/length code", n.mode = 30; break t } w = 65535 & y, (v &= 15) && (p < v && (d += A[r++] << p, p += 8), w += d & (1 << v) - 1, d >>>= v, p -= v), p < 15 && (d += A[r++] << p, p += 8, d += A[r++] << p, p += 8), y = _[d & m]; n: for (; ;) { if (d >>>= v = y >>> 24, p -= v, !(16 & (v = y >>> 16 & 255))) { if (0 == (64 & v)) { y = _[(65535 & y) + (d & (1 << v) - 1)]; continue n } t.msg = "invalid distance code", n.mode = 30; break t } if (E = 65535 & y, p < (v &= 15) && (d += A[r++] << p, (p += 8) < v && (d += A[r++] << p, p += 8)), u < (E += d & (1 << v) - 1)) { t.msg = "invalid distance too far back", n.mode = 30; break t } if (d >>>= v, p -= v, (v = a - o) < E) { if (c < (v = E - v) && n.sane) { t.msg = "invalid distance too far back", n.mode = 30; break t } if (S = h, (T = 0) === f) { if (T += l - v, v < w) { for (w -= v; k[a++] = h[T++], --v;); T = a - E, S = k } } else if (f < v) { if (T += l + f - v, (v -= f) < w) { for (w -= v; k[a++] = h[T++], --v;); if (T = 0, f < w) { for (w -= v = f; k[a++] = h[T++], --v;); T = a - E, S = k } } } else if (T += f - v, v < w) { for (w -= v; k[a++] = h[T++], --v;); T = a - E, S = k } for (; 2 < w;)k[a++] = S[T++], k[a++] = S[T++], k[a++] = S[T++], w -= 3; w && (k[a++] = S[T++], 1 < w && (k[a++] = S[T++])) } else { for (T = a - E; k[a++] = k[T++], k[a++] = k[T++], k[a++] = k[T++], 2 < (w -= 3);); w && (k[a++] = k[T++], 1 < w && (k[a++] = k[T++])) } break } } break } } while (r < i && a < s); r -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, t.next_in = r, t.next_out = a, t.avail_in = r < i ? i - r + 5 : 5 - (r - i), t.avail_out = a < s ? s - a + 257 : 257 - (a - s), n.hold = d, n.bits = p } }, function (t, e, n) { "use strict"; var P = n(9), C = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], F = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], M = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], B = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]; t.exports = function (t, e, n, r, i, a, o, s) { var u, l, c, f, h, d, p, g, _, b = s.bits, m = 0, y = 0, v = 0, w = 0, E = 0, T = 0, S = 0, A = 0, k = 0, I = 0, O = null, x = 0, R = new P.Buf16(16), N = new P.Buf16(16), L = null, D = 0; for (m = 0; m <= 15; m++)R[m] = 0; for (y = 0; y < r; y++)R[e[n + y]]++; for (E = b, w = 15; 1 <= w && 0 === R[w]; w--); if (w < E && (E = w), 0 === w) return i[a++] = 20971520, i[a++] = 20971520, s.bits = 1, 0; for (v = 1; v < w && 0 === R[v]; v++); for (E < v && (E = v), m = A = 1; m <= 15; m++)if (A <<= 1, (A -= R[m]) < 0) return -1; if (0 < A && (0 === t || 1 !== w)) return -1; for (N[1] = 0, m = 1; m < 15; m++)N[m + 1] = N[m] + R[m]; for (y = 0; y < r; y++)0 !== e[n + y] && (o[N[e[n + y]]++] = y); if (d = 0 === t ? (O = L = o, 19) : 1 === t ? (O = C, x -= 257, L = F, D -= 257, 256) : (O = M, L = B, -1), m = v, h = a, S = y = I = 0, c = -1, f = (k = 1 << (T = E)) - 1, 1 === t && 852 < k || 2 === t && 592 < k) return 1; for (; ;) { for (p = m - S, _ = o[y] < d ? (g = 0, o[y]) : o[y] > d ? (g = L[D + o[y]], O[x + o[y]]) : (g = 96, 0), u = 1 << m - S, v = l = 1 << T; i[h + (I >> S) + (l -= u)] = p << 24 | g << 16 | _ | 0, 0 !== l;); for (u = 1 << m - 1; I & u;)u >>= 1; if (0 !== u ? (I &= u - 1, I += u) : I = 0, y++ , 0 == --R[m]) { if (m === w) break; m = e[n + o[y]] } if (E < m && (I & f) !== c) { for (0 === S && (S = E), h += v, A = 1 << (T = m - S); T + S < w && !((A -= R[T + S]) <= 0);)T++ , A <<= 1; if (k += 1 << T, 1 === t && 852 < k || 2 === t && 592 < k) return 1; i[c = I & f] = E << 24 | T << 16 | h - a | 0 } } return 0 !== I && (i[h + I] = m - S << 24 | 64 << 16 | 0), s.bits = E, 0 } }, function (t, e, n) { "use strict"; t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 } }, function (t, e) { function n() { this.pending = 0, this.max = 1 / 0, this.listeners = [], this.waiting = [], this.error = null } function r(n) { n.pending += 1; var r = !1; return function (t) { if (r) throw new Error("callback called twice"); if (r = !0, n.error = n.error || t, n.pending -= 1, 0 < n.waiting.length && n.pending < n.max) a(n, n.waiting.shift()); else if (0 === n.pending) { var e = n.listeners; n.listeners = [], e.forEach(i) } }; function i(t) { t(n.error) } } function a(t, e) { e(r(t)) } (t.exports = n).prototype.go = function (t) { this.pending < this.max ? a(this, t) : this.waiting.push(t) }, n.prototype.wait = function (t) { 0 === this.pending ? t(this.error) : this.listeners.push(t) }, n.prototype.hold = function () { return r(this) } }, function (t, e, n) { "use strict"; n.r(e); var r = n(6), s = n.n(r); function i(t) { return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function a(t) { return (a = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } function o(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function u(t, e) { return (u = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } var l = function (t) { function r(t, e) { var n; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, r), n = function (t, e) { return !e || "object" !== i(e) && "function" != typeof e ? o(t) : e }(this, a(r).call(this)), Object.assign(o(n), t), n.alpha = t.opacity, t.image && t.image.source && n.addChild(PIXI.Sprite.fromImage("".concat(e, "/").concat(t.image.source))), n } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && u(t, e) }(r, PIXI.Container), r }(); function c(t) { return (c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function f(t) { return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } function h(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function d(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function p(t, e, n) { return e && d(t.prototype, e), n && d(t, n), t } function g(t, e) { return (g = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function _(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var b = function (t) { function o(t, e, n, r, i) { var a; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, o), _(h(a = function (t, e) { return !e || "object" !== c(e) && "function" != typeof e ? h(t) : e }(this, f(o).call(this, o.getTextures(t, e)))), "animations", []), _(h(a), "gid", 0), _(h(a), "_x", 0), _(h(a), "_y", 0), _(h(a), "tile", void 0), _(h(a), "tileSet", void 0), _(h(a), "horizontalFlip", void 0), _(h(a), "verticalFlip", void 0), _(h(a), "diagonalFlip", void 0), a.textures = o.getTextures(t, e), a.tile = t, a.tileSet = e, a.horizontalFlip = n, a.verticalFlip = r, a.diagonalFlip = i, Object.assign(h(a), t), a.flip(), a } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && g(t, e) }(o, PIXI.extras.AnimatedSprite), p(o, null, [{ key: "getTextures", value: function (t, e) { var n = []; return t.animations.length ? t.animations.forEach(function (t) { n.push(e.textures[t.tileId]) }) : n.push(e.textures[t.gid - e.firstGid]), n } }]), p(o, [{ key: "flip", value: function () { this.horizontalFlip && (this.anchor.x = 1, this.scale.x = -1), this.verticalFlip && (this.anchor.y = 1, this.scale.y = -1), this.diagonalFlip && (this.horizontalFlip && (this.anchor.x = 0, this.scale.x = 1, this.anchor.y = 1, this.scale.y = 1, this.rotation = 90 * PIXI.DEG_TO_RAD), this.verticalFlip && (this.anchor.x = 1, this.scale.x = 1, this.anchor.y = 0, this.scale.y = 1, this.rotation = -90 * PIXI.DEG_TO_RAD)) } }]), o }(); function m(t) { return (m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function y(t) { return (y = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } function v(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function w(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function E(t, e, n) { return e && w(t.prototype, e), n && w(t, n), t } function T(t, e) { return (T = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function S(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var A = function (t) { function a(t, e) { var n; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, a), S(v(n = function (t, e) { return !e || "object" !== m(e) && "function" != typeof e ? v(t) : e }(this, y(a).call(this))), "layer", void 0), S(v(n), "tileSets", void 0), S(v(n), "tiles", void 0), n.layer = t, n.tileSets = e, n.alpha = t.opacity, n.tiles = [], Object.assign(v(n), t), n.create(), n } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && T(t, e) }(a, PIXI.Container), E(a, null, [{ key: "findTileSet", value: function (t, e) { for (var n, r = e.length - 1; 0 <= r && !((n = e[r]).firstGid && n.firstGid <= t); r--); return n } }]), E(a, [{ key: "create", value: function () { for (var t = 0; t < this.layer.map.height; t++)for (var e = 0; e < this.layer.map.width; e++) { var n = e + t * this.layer.map.width; if (this.layer.tiles[n] && this.layer.tiles[n].gid && 0 !== this.layer.tiles[n].gid) { var r = a.findTileSet(this.layer.tiles[n].gid, this.tileSets); if (r) { var i = new b(this.layer.tiles[n], r, this.layer.horizontalFlips[n], this.layer.verticalFlips[n], this.layer.diagonalFlips[n]); i.x = e * this.layer.map.tileWidth, i.y = t * this.layer.map.tileHeight + (this.layer.map.tileHeight - i.textures[0].height), i._x = e, i._y = t, r.tileOffset && (i.x += r.tileOffset.x, i.y += r.tileOffset.y), 1 < i.textures.length && (i.animationSpeed = 1e3 / 60 / i.animations[0].duration, i.gotoAndPlay(0)), this.tiles.push(i), this.addChild(i) } } } } }]), a }(); function k(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function I(t, e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, I), k(this, "firstGid", 0), k(this, "baseTexture", void 0), k(this, "textures", void 0), k(this, "margin", 0), k(this, "spacing", 0), k(this, "tileHeight", 0), k(this, "tileWidth", 0), k(this, "image", { height: 0, source: "", width: 0 }), k(this, "tileOffset", void 0), Object.assign(this, e), this.baseTexture = PIXI.Texture.fromImage("".concat(t, "/").concat(this.image.source), !1, PIXI.SCALE_MODES.NEAREST), this.textures = []; for (var n = this.margin; n < this.image.height; n += this.tileHeight + this.spacing)for (var r = this.margin; r < this.image.width; r += this.tileWidth + this.spacing)this.textures.push(new PIXI.Texture(this.baseTexture, new PIXI.Rectangle(r, n, this.tileWidth, this.tileHeight))) } function O(t) { return (O = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function x(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function R(t) { return (R = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } function N(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function L(t, e) { return (L = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function D(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var P = function (t) { function n(t) { var e; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, n), D(N(e = function (t, e) { return !e || "object" !== O(e) && "function" != typeof e ? N(t) : e }(this, R(n).call(this))), "resourceUrl", void 0), D(N(e), "tileSets", []), D(N(e), "layers", {}), D(N(e), "background", new PIXI.Graphics), D(N(e), "_width", void 0), D(N(e), "tileWidth", 0), D(N(e), "_height", void 0), D(N(e), "tileHeight", 0), e.resourceUrl = t, e.create(), e } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && L(t, e) }(n, PIXI.Container), function (t, e, n) { e && x(t.prototype, e), n && x(t, n) }(n, [{ key: "create", value: function () { var r = this, i = s.a.dirname(PIXI.loader.resources[this.resourceUrl].url), t = PIXI.loader.resources[this.resourceUrl].data; Object.assign(this, t), this.background.beginFill(0, 0), this.background.drawRect(0, 0, (this._width || 0) * (this.tileWidth || 0), (this._height || 0) * (this.tileHeight || 0)), this.background.endFill(), this.addChild(this.background), t.tileSets.forEach(function (t) { r.tileSets.push(new I(i, t)) }), t.layers.forEach(function (t) { switch (t.type) { case "tile": var e = new A(t, r.tileSets); r.layers[t.name] = e, r.addChild(e); break; case "image": var n = new l(t, i); r.layers[t.name] = n, r.addChild(n) } }) } }]), n }(), C = n(24); var F = function () { var o = this; return function (n, r) { if (!n.data || n.type !== PIXI.loaders.Resource.TYPE.XML || !n.data.children[0].getElementsByTagName("tileset")) return r(); var i = s.a.dirname(n.url.replace(o.baseUrl, "")), a = { crossOrigin: n.crossOrigin, parentResource: n }; C.parse(n.xhr.responseText, i, function (t, e) { if (t) throw t; e.tileSets.forEach(function (t) { t.image.source in o.resources || o.add(t.image.source, "".concat(i, "/").concat(t.image.source), a) }), n.data = e, r() }) } }; PIXI.loaders.Loader.addPixiMiddleware(F), PIXI.loader.use(F.call(PIXI.loader)), Object.assign(PIXI.extras, { TiledMap: P }); e.default = P }])
});
//# sourceMappingURL=pixi-tiledmap.min.js.map